{
  "typescript-implement": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up TypeScript and Initial Configuration",
        "description": "Install TypeScript and related dependencies, create tsconfig.json with appropriate compiler options, and set up the initial build process integration.",
        "details": "1. Install required dependencies:\n```bash\nnpm install --save-dev typescript @types/node ts-node\n```\n2. Create a tsconfig.json file with the following configuration:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"outDir\": \"dist\",\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"*\": [\"node_modules/*\"]\n    },\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\", \".eleventy.ts\", \"public/assets/js/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n3. Update package.json to include TypeScript compilation scripts:\n```json\n\"scripts\": {\n  \"build:ts\": \"tsc\",\n  \"dev:ts\": \"tsc --watch\",\n  \"type-check\": \"tsc --noEmit\"\n}\n```\n4. Create a types directory with an initial index.d.ts file for shared type definitions.\n<info added on 2025-09-13T04:36:13.332Z>\n5. Verified all required devDependencies are installed:\n   - typescript\n   - ts-node\n   - @types/node\n\n6. Confirmed tsconfig.json has appropriate strict settings and incremental build configuration.\n\n7. Noted that scripts are already configured to preload ts-node/register for Eleventy in development and build processes.\n\n8. Next steps:\n   - Run `npm run type-check` to verify TypeScript configuration\n   - Create a simple .ts file and test the build process\n   - Create the types/ directory with an initial index.d.ts file for shared type definitions if not already present\n</info added on 2025-09-13T04:36:13.332Z>",
        "testStrategy": "Verify TypeScript installation by running 'npx tsc --version'. Validate tsconfig.json by running 'npm run type-check' and ensuring it completes without errors. Test the build process by creating a simple .ts file and confirming it compiles correctly.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create Core Type Definitions",
        "description": "Define shared TypeScript interfaces and types for project metadata, frontmatter, internationalization, date formatting, and content processing.",
        "details": "Create the following type definition files in the types/ directory:\n\n1. `types/eleventy.d.ts` - Eleventy-specific types:\n```typescript\nexport interface EleventyConfig {\n  addPassthroughCopy: (path: string) => void;\n  addFilter: (name: string, fn: Function) => void;\n  addCollection: (name: string, fn: Function) => EleventyCollection;\n  // Add other Eleventy methods as needed\n}\n\nexport interface EleventyCollection {\n  getAll: () => CollectionItem[];\n  getAllSorted: () => CollectionItem[];\n  // Add other collection methods as needed\n}\n\nexport interface CollectionItem {\n  data: {\n    title: string;\n    date: Date;\n    tags?: string[];\n    [key: string]: any;\n  };\n  url: string;\n  inputPath: string;\n  outputPath: string;\n  // Add other properties as needed\n}\n```\n\n2. `types/content.d.ts` - Content and frontmatter types:\n```typescript\nexport interface Frontmatter {\n  title: string;\n  date: string | Date;\n  tags?: string[];\n  lang?: string;\n  description?: string;\n  [key: string]: any;\n}\n\nexport interface ContentItem {\n  data: Frontmatter;\n  content: string;\n  [key: string]: any;\n}\n```\n\n3. `types/i18n.d.ts` - Internationalization types:\n```typescript\nexport interface TranslationDictionary {\n  [key: string]: string | TranslationDictionary;\n}\n\nexport interface I18nConfig {\n  defaultLanguage: string;\n  languages: string[];\n  translations: {\n    [language: string]: TranslationDictionary;\n  };\n}\n```\n\n4. `types/utils.d.ts` - Utility function types:\n```typescript\nexport interface DateFormatOptions {\n  format?: string;\n  locale?: string;\n}\n\nexport interface ContentFilterOptions {\n  tag?: string | string[];\n  language?: string;\n  limit?: number;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n}\n```",
        "testStrategy": "Validate type definitions by creating test files that import and use these types. Run TypeScript compiler with 'npm run type-check' to ensure there are no type errors. Create sample objects that implement these interfaces and verify they match the expected structure.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Complete TypeScript Migration with Code Consolidation and Transpilation Validation",
        "description": "Convert all utility files in src/utils/ to TypeScript with comprehensive type definitions, consolidate JavaScript implementations into TypeScript files, and validate transpilation output for production compatibility. This includes migrating i18n, dates, format, and content processing utilities with advanced error handling, performance optimization, and cross-browser compatibility validation.",
        "details": "For each utility file in src/utils/, perform a complete migration with code consolidation:\n\n1. **Code Consolidation Phase:**\n   - Move all JavaScript implementation code from .js files directly into corresponding .ts files\n   - Remove wrapper pattern and integrate original logic with TypeScript annotations\n   - Ensure no runtime dependencies on original .js files remain\n\n2. **Advanced TypeScript Implementation:**\n   - Add comprehensive type annotations using union types, generics, and conditional types\n   - Implement strict null checks and undefined handling\n   - Create custom type guards with proper narrowing\n   - Add JSDoc comments with @param and @return type documentation\n\n3. **Enhanced Error Handling:**\n   - Implement custom error classes with proper inheritance\n   - Add input validation with detailed error messages\n   - Create fallback mechanisms for edge cases\n   - Add logging integration for debugging purposes\n\n4. **Performance and Compatibility:**\n   - Optimize for tree-shaking with proper ES6 module exports\n   - Add polyfill detection and conditional loading\n   - Implement lazy loading for heavy utility functions\n   - Add memory leak prevention for event listeners and timers\n\n5. **Transpilation Validation:**\n   - Configure TypeScript compiler with strict mode enabled\n   - Validate output JavaScript matches expected ES5/ES2015 targets\n   - Test transpiled code in multiple browser environments\n   - Verify source map generation for debugging\n   - Check bundle size impact and optimization opportunities\n\nExample enhanced implementation:\n```typescript\n// src/utils/dates.ts (consolidated from dates.js)\nimport { DateFormatOptions, DateValidationResult, CustomDateError } from '../../types/utils';\n\nexport class DateUtilityError extends Error {\n  constructor(message: string, public readonly input: unknown) {\n    super(message);\n    this.name = 'DateUtilityError';\n  }\n}\n\nexport function formatDate<T extends Date | string | number>(\n  date: T, \n  options: DateFormatOptions = {}\n): string {\n  const { format = 'yyyy-MM-dd', locale = 'en-US', timezone, fallback } = options;\n  \n  try {\n    const dateObj = normalizeDate(date);\n    if (!isValidDate(dateObj)) {\n      if (fallback) return fallback;\n      throw new DateUtilityError(`Invalid date provided: ${date}`, date);\n    }\n    \n    // Enhanced formatting with timezone support\n    const formatter = new Intl.DateTimeFormat(locale, {\n      timeZone: timezone,\n      ...parseFormatString(format)\n    });\n    \n    return formatter.format(dateObj);\n  } catch (error) {\n    if (error instanceof DateUtilityError) throw error;\n    throw new DateUtilityError(`Date formatting failed: ${error.message}`, date);\n  }\n}\n\nexport function validateDateRange(\n  startDate: Date | string, \n  endDate: Date | string,\n  options: { allowSameDay?: boolean; maxRange?: number } = {}\n): DateValidationResult {\n  // Comprehensive validation logic with detailed results\n}\n\n// Advanced type guards with proper narrowing\nexport function isValidDate(date: unknown): date is Date {\n  return date instanceof Date && !isNaN(date.getTime()) && isFinite(date.getTime());\n}\n\nfunction normalizeDate(input: Date | string | number): Date {\n  if (input instanceof Date) return input;\n  if (typeof input === 'string' || typeof input === 'number') {\n    return new Date(input);\n  }\n  throw new DateUtilityError('Unsupported date input type', input);\n}\n```\n\n6. **Build Configuration:**\n   - Update tsconfig.json with strict compilation settings\n   - Configure webpack/rollup for proper TypeScript handling\n   - Set up pre-commit hooks for type checking\n   - Add TypeScript declaration file generation\n\n7. **Migration Verification:**\n   - Compare runtime behavior between original JS and new TS implementations\n   - Validate all existing API contracts remain unchanged\n   - Test with real-world data sets and edge cases\n   - Performance benchmark against original implementations",
        "testStrategy": "Implement comprehensive testing strategy with multiple validation layers:\n\n1. **Unit Testing with Type Validation:**\n   - Create Jest tests with TypeScript support and @types/jest\n   - Test all function signatures with correct and incorrect types\n   - Validate error handling with custom error classes\n   - Test edge cases including null, undefined, and malformed inputs\n   - Use property-based testing with fast-check for random input validation\n\n2. **Integration Testing:**\n   - Test utility functions working together in realistic scenarios\n   - Validate i18n utilities with actual translation files\n   - Test date utilities with different locales and timezones\n   - Verify format utilities with various data structures\n\n3. **Transpilation and Build Testing:**\n   - Automated testing of TypeScript compilation process\n   - Validate generated JavaScript output in multiple environments (Node.js, browsers)\n   - Test source map accuracy for debugging\n   - Bundle size regression testing\n   - Cross-browser compatibility testing (Chrome, Firefox, Safari, Edge)\n\n4. **Performance and Memory Testing:**\n   - Benchmark performance against original JavaScript implementations\n   - Memory leak detection for long-running processes\n   - Load testing with large datasets\n   - Profiling of transpiled code execution\n\n5. **Type Safety Validation:**\n   - Use tsc --noEmit for compile-time type checking\n   - Test with strict TypeScript compiler settings\n   - Validate IntelliSense and IDE support\n   - Test type inference and auto-completion\n\n6. **Regression Testing:**\n   - Maintain existing test suite compatibility\n   - Compare outputs between old JS and new TS implementations\n   - Test with production data samples\n   - Validate backward compatibility for existing consumers",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TypeScript Type Definitions for Utility Functions",
            "description": "Create TypeScript interface and type definitions for all utility functions before modifying the actual implementation files. This includes types for i18n, dates, formatting, and content processing utilities.",
            "dependencies": [],
            "details": "Create a new directory structure in src/types/ with separate files for each utility category:\n\n1. src/types/utils/dates.ts:\n```typescript\nexport interface DateFormatOptions {\n  format?: string;\n  locale?: string;\n  timezone?: string;\n}\n```\n\n2. src/types/utils/i18n.ts:\n```typescript\nexport interface TranslationDictionary {\n  [key: string]: string | TranslationDictionary;\n}\n\nexport interface I18nConfig {\n  defaultLanguage: string;\n  supportedLanguages: string[];\n  translations: {\n    [language: string]: TranslationDictionary;\n  };\n}\n```\n\n3. src/types/utils/format.ts:\n```typescript\nexport interface FormatOptions {\n  truncate?: number;\n  capitalize?: boolean;\n  lowercase?: boolean;\n  uppercase?: boolean;\n}\n```\n\n4. src/types/utils/content.ts:\n```typescript\nexport interface ContentProcessingOptions {\n  stripHtml?: boolean;\n  excerpt?: number;\n  markdown?: boolean;\n}\n\nexport interface ContentItem {\n  content: string;\n  data?: Record<string, unknown>;\n  [key: string]: unknown;\n}\n```",
            "status": "done",
            "testStrategy": "Validate type definitions by creating a simple test file that imports and uses these types. Ensure the TypeScript compiler accepts the types without errors."
          },
          {
            "id": 2,
            "title": "Create TypeScript Wrapper Functions for Date Utilities",
            "description": "Create TypeScript wrapper functions for date utilities that use the type definitions while maintaining the original JavaScript files. This allows for incremental migration without breaking existing functionality.",
            "dependencies": [
              "3.1"
            ],
            "details": "1. Create a new file src/utils/dates.ts that imports the original JavaScript functions and wraps them with typed versions:\n\n```typescript\nimport { DateFormatOptions } from '../../types/utils/dates';\n// Import the original functions\nimport * as originalDates from './dates.js';\n\nexport function formatDate(date: Date | string, options: DateFormatOptions = {}): string {\n  return originalDates.formatDate(date, options);\n}\n\nexport function isValidDate(date: unknown): date is Date {\n  return date instanceof Date && !isNaN(date.getTime());\n}\n\nexport function parseDate(dateString: string): Date {\n  const result = originalDates.parseDate(dateString);\n  if (!isValidDate(result)) {\n    throw new Error(`Invalid date string: ${dateString}`);\n  }\n  return result;\n}\n\nexport function dateDifference(date1: Date | string, date2: Date | string): number {\n  const d1 = typeof date1 === 'string' ? parseDate(date1) : date1;\n  const d2 = typeof date2 === 'string' ? parseDate(date2) : date2;\n  return originalDates.dateDifference(d1, d2);\n}\n```\n\n2. Update the build process to compile TypeScript files alongside JavaScript files without replacing them yet.",
            "status": "done",
            "testStrategy": "Write unit tests for each wrapper function to verify they correctly call the original functions with the same parameters and return the expected results. Test edge cases like invalid dates and different format options."
          },
          {
            "id": 3,
            "title": "Migrate I18n and Formatting Utility Functions to TypeScript",
            "description": "Convert the i18n and formatting utility functions to TypeScript using the previously defined type definitions, implementing proper error handling and type guards.",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "1. Create src/utils/i18n.ts:\n```typescript\nimport { TranslationDictionary, I18nConfig } from '../../types/utils/i18n';\n\nexport function translate(key: string, language: string, translations: I18nConfig['translations']): string {\n  if (!translations[language]) {\n    console.warn(`Language \"${language}\" not found in translations`);\n    return key; // Fallback to key if language not found\n  }\n  \n  // Navigate nested translation objects\n  const keyParts = key.split('.');\n  let result: string | TranslationDictionary = translations[language];\n  \n  for (const part of keyParts) {\n    if (typeof result === 'string') {\n      return result;\n    }\n    \n    result = (result as TranslationDictionary)[part] as string | TranslationDictionary;\n    if (result === undefined) {\n      console.warn(`Translation key \"${key}\" not found for language \"${language}\"`);\n      return key; // Key not found\n    }\n  }\n  \n  return typeof result === 'string' ? result : key;\n}\n\nexport function getLanguageFromUrl(url: string, supportedLanguages: string[]): string {\n  const pathSegments = url.split('/').filter(Boolean);\n  const potentialLang = pathSegments[0];\n  \n  return supportedLanguages.includes(potentialLang) ? potentialLang : 'en';\n}\n```\n\n2. Create src/utils/format.ts:\n```typescript\nimport { FormatOptions } from '../../types/utils/format';\n\nexport function formatText(text: string, options: FormatOptions = {}): string {\n  let result = text;\n  \n  if (options.truncate && result.length > options.truncate) {\n    result = result.substring(0, options.truncate) + '...';\n  }\n  \n  if (options.capitalize) {\n    result = result.charAt(0).toUpperCase() + result.slice(1);\n  }\n  \n  if (options.lowercase) {\n    result = result.toLowerCase();\n  }\n  \n  if (options.uppercase) {\n    result = result.toUpperCase();\n  }\n  \n  return result;\n}\n\nexport function slugify(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/[^\\w\\s-]/g, '') // Remove non-word chars\n    .replace(/[\\s_-]+/g, '-') // Replace spaces and underscores with hyphens\n    .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens\n}\n```",
            "status": "done",
            "testStrategy": "Create comprehensive unit tests for the i18n and formatting functions. Test nested translation keys, missing languages, and various formatting options. Verify that error handling works correctly by testing edge cases."
          },
          {
            "id": 4,
            "title": "Migrate Content Processing Utility Functions to TypeScript",
            "description": "Convert content processing utility functions to TypeScript with proper type definitions, error handling, and type guards for processing markdown, HTML, and other content types.",
            "dependencies": [
              "3.1",
              "3.3"
            ],
            "details": "1. Create src/utils/content.ts:\n```typescript\nimport { ContentProcessingOptions, ContentItem } from '../../types/utils/content';\n\nexport function processContent(content: string, options: ContentProcessingOptions = {}): string {\n  let result = content;\n  \n  if (options.stripHtml) {\n    result = result.replace(/<[^>]*>/g, '');\n  }\n  \n  if (options.excerpt && result.length > options.excerpt) {\n    result = result.substring(0, options.excerpt) + '...';\n  }\n  \n  return result;\n}\n\nexport function extractExcerpt(content: string, length: number = 150): string {\n  // First strip HTML\n  const strippedContent = content.replace(/<[^>]*>/g, '');\n  \n  // Then create excerpt\n  if (strippedContent.length <= length) {\n    return strippedContent;\n  }\n  \n  return strippedContent.substring(0, length) + '...';\n}\n\nexport function sortContentItems(items: ContentItem[], sortBy: string = 'date', order: 'asc' | 'desc' = 'desc'): ContentItem[] {\n  return [...items].sort((a, b) => {\n    const aValue = a.data?.[sortBy];\n    const bValue = b.data?.[sortBy];\n    \n    if (aValue === undefined && bValue === undefined) return 0;\n    if (aValue === undefined) return order === 'asc' ? 1 : -1;\n    if (bValue === undefined) return order === 'asc' ? -1 : 1;\n    \n    if (aValue instanceof Date && bValue instanceof Date) {\n      return order === 'asc' \n        ? aValue.getTime() - bValue.getTime() \n        : bValue.getTime() - aValue.getTime();\n    }\n    \n    if (typeof aValue === 'string' && typeof bValue === 'string') {\n      return order === 'asc' \n        ? aValue.localeCompare(bValue) \n        : bValue.localeCompare(aValue);\n    }\n    \n    if (typeof aValue === 'number' && typeof bValue === 'number') {\n      return order === 'asc' ? aValue - bValue : bValue - aValue;\n    }\n    \n    return 0;\n  });\n}\n```",
            "status": "done",
            "testStrategy": "Write unit tests for content processing functions with various input types and options. Test HTML stripping, excerpt generation, and content sorting with different data types. Verify that the functions handle edge cases like empty content or missing data fields."
          },
          {
            "id": 5,
            "title": "Advanced TypeScript Migration with Custom Error Classes and Type Guards",
            "description": "Perform comprehensive TypeScript migration of all utility files with advanced type annotations, custom error classes, and sophisticated type guards. This includes implementing union types, generics, conditional types, and strict null checking across all utilities.",
            "dependencies": [
              "3.3",
              "3.4"
            ],
            "details": "Migrate each utility file (i18n, dates, format, content processing) to TypeScript with: 1) Custom error classes extending base Error with proper inheritance and context data, 2) Advanced type guards using 'is' predicates for runtime type narrowing, 3) Generic functions with constraints and conditional types, 4) Comprehensive JSDoc documentation with @param, @return, and @throws annotations, 5) Strict null checks and undefined handling with proper optional chaining, 6) Union types for flexible input handling, 7) Interface definitions for complex data structures, 8) Type assertion functions for runtime validation.",
            "status": "done",
            "testStrategy": "Unit tests with TypeScript type validation using Jest and @types/jest. Test type guards with various input types, validate custom error classes with proper inheritance chains, test generic functions with different type parameters, and use property-based testing with fast-check for comprehensive input validation. Include compile-time type checking with tsc --noEmit."
          },
          {
            "id": 6,
            "title": "Code Consolidation",
            "description": "Consolidate JavaScript implementations directly into TypeScript files. Remove all wrapper patterns and ensure zero runtime dependencies on original JavaScript files.",
            "dependencies": [
              "3.5"
            ],
            "details": "For each utility: 1) Move all JavaScript code directly into .ts files, eliminating wrapper patterns, 2) Implement ES6 module exports optimized for tree-shaking with proper named exports, 3) Add lazy loading mechanisms for heavy utility functions using dynamic imports, 4) Implement memory leak prevention for event listeners, timers, and DOM references, 5) Add polyfill detection and conditional loading for browser compatibility, 6) Optimize function implementations for V8 engine performance, 7) Implement caching mechanisms for expensive operations, 8) Add proper cleanup methods for stateful utilities.",
            "status": "done",
            "testStrategy": "Unit tests with TypeScript type validation using Jest and @types/jest. Test type guards with various input types, validate custom error classes with proper inheritance chains, test generic functions with different type parameters, and use property-based testing with fast-check for comprehensive input validation. Include compile-time type checking with tsc --noEmit."
          },
          {
            "id": 7,
            "title": "Enhanced Error Handling with Logging Integration and Fallback Mechanisms",
            "description": "Implement comprehensive error handling system with custom error hierarchies, detailed error messages, fallback mechanisms for edge cases, and integrated logging for debugging and monitoring purposes.",
            "dependencies": [
              "3.5"
            ],
            "details": "Create robust error handling: 1) Design custom error class hierarchy (DateUtilityError, I18nError, FormatError, ContentProcessingError) with proper inheritance, 2) Implement input validation with detailed error messages including expected vs actual types, 3) Add fallback mechanisms for graceful degradation (default values, alternative implementations), 4) Integrate logging system with configurable log levels (debug, info, warn, error), 5) Add error context preservation with stack traces and input data, 6) Implement retry mechanisms for transient failures, 7) Add error aggregation for batch operations, 8) Create error reporting utilities for production monitoring.\n<info added on 2025-09-13T19:11:44.554Z>\nBased on your progress, the next steps involve applying the newly created error classes and logger utility to the core utility functions. The focus should be on robust input validation, graceful fallbacks, and contextual logging.\n\n**Implementation Plan:**\n\n1.  **Integrate into `src/utils/dates.ts`:**\n    *   In functions like `formatDate` and `getReadableDate`, add input validation at the beginning. Check if the `date` parameter is a valid `Date` object or a parseable date string.\n    *   If validation fails, throw a `new DateUtilityError()` from `src/utils/errors.ts` with a message detailing the expected vs. actual input type.\n    *   Wrap the core `Intl.DateTimeFormat` logic in a `try...catch` block. On failure (e.g., invalid locale), catch the original error, log it with context using the `logger` from `src/utils/logger.ts`, and re-throw a `DateUtilityError`.\n    *   **Example Pattern:**\n        ```typescript\n        import { logger } from './logger';\n        import { DateUtilityError } from './errors';\n\n        export function formatDate(date: unknown, locale: string = 'en-US'): string {\n          const dateObj = new Date(date as any);\n          if (isNaN(dateObj.getTime())) {\n            logger.warn({ input: date }, 'Invalid date input received.');\n            throw new DateUtilityError(`Invalid date value: ${date}`);\n          }\n          try {\n            // ... formatting logic ...\n          } catch (error) {\n            logger.error({ error, date, locale }, 'Failed to format date.');\n            // Fallback to a simple string representation\n            return dateObj.toISOString();\n          }\n        }\n        ```\n\n2.  **Enhance `src/utils/i18n.ts`:**\n    *   In the main translation function, check if a translation key exists for the given locale.\n    *   If the key is missing, implement a fallback mechanism: log a warning with `logger.warn({ key, locale }, 'Missing translation key.')` and return the key itself or a default placeholder string (e.g., `[MISSING_TRANSLATION: ${key}]`). This prevents the UI from breaking.\n    *   If the entire locale file or data structure is invalid, catch the error, log it, and throw a `new I18nError('Failed to load or parse locale data.')`.\n\n3.  **Fortify `src/utils/format.ts` and `src/utils/content.ts`:**\n    *   For any functions that perform formatting or content processing, apply the same pattern: validate inputs, wrap logic in `try...catch`, and use the `logger` for detailed context.\n    *   Throw specific errors like `FormatError` or `ContentProcessingError` from `src/utils/errors.ts`.\n    *   When logging an error, include the input arguments and any relevant options to preserve context for debugging. For example: `logger.error({ input, options, originalError: error }, 'Content processing failed.');`\n</info added on 2025-09-13T19:11:44.554Z>",
            "status": "done",
            "testStrategy": "Error handling tests covering all error scenarios with proper error type validation. Test fallback mechanisms with various failure conditions. Validate logging integration with different log levels and outputs. Test error context preservation and stack trace accuracy. Simulate network failures and resource constraints to test retry mechanisms. Use chaos engineering principles to test system resilience."
          },
          {
            "id": 8,
            "title": "Transpilation Validation with Multi-Environment Testing and Source Map Verification",
            "description": "Configure and validate TypeScript transpilation process with strict compiler settings, multi-target output validation, cross-browser testing, and comprehensive source map verification for production deployment.",
            "dependencies": [
              "3.6",
              "3.7"
            ],
            "details": "Comprehensive transpilation validation: 1) Configure tsconfig.json with strict mode, noImplicitAny, strictNullChecks, and noImplicitReturns, 2) Set up multi-target compilation (ES5, ES2015, ES2020) with appropriate polyfills, 3) Validate transpiled JavaScript output matches expected syntax and behavior, 4) Test in multiple runtime environments (Node.js versions, browser engines), 5) Verify source map generation and accuracy for debugging, 6) Implement bundle size monitoring with regression detection, 7) Add pre-commit hooks for type checking and compilation validation, 8) Configure webpack/rollup for optimal TypeScript handling with proper module resolution, 9) Test declaration file generation for library consumers.\n<info added on 2025-09-13T19:14:27.257Z>\nUpdate: Transpilation validation has been successfully completed. The `tsconfig.json` is now configured with advanced strict compilation settings, including `noImplicitAny`, `strictNullChecks`, and `exactOptionalPropertyTypes`. The build process has been verified to correctly generate JavaScript files, `.d.ts` declaration files, and accurate source maps. All identified type errors have been resolved, and the output has been validated across multiple environments.\n</info added on 2025-09-13T19:14:27.257Z>",
            "status": "done",
            "testStrategy": "Automated transpilation testing with multiple TypeScript compiler targets. Cross-browser testing using Selenium WebDriver or Playwright across Chrome, Firefox, Safari, and Edge. Source map validation by testing breakpoint accuracy and variable inspection. Bundle size regression testing with automated alerts for size increases. Runtime behavior comparison between original JavaScript and transpiled TypeScript using automated test suites. Performance profiling of transpiled code in production-like environments."
          }
        ]
      },
      {
        "id": 4,
        "title": "Convert Eleventy Configuration to TypeScript",
        "description": "Migrate the .eleventy.js configuration file to TypeScript with proper type definitions and ensure compatibility with the Eleventy build process.",
        "details": "1. Create a new .eleventy.ts file with the following structure:\n\n```typescript\nimport { EleventyConfig } from './types/eleventy';\n\n// Import utility functions\nimport { formatDate } from './src/utils/dates';\nimport { translate } from './src/utils/i18n';\n// Import other utilities as needed\n\nmodule.exports = function(eleventyConfig: EleventyConfig) {\n  // Add passthrough copy\n  eleventyConfig.addPassthroughCopy('src/assets');\n  \n  // Add filters\n  eleventyConfig.addFilter('formatDate', formatDate);\n  eleventyConfig.addFilter('translate', translate);\n  \n  // Add collections\n  eleventyConfig.addCollection('posts', (collection) => {\n    return collection.getAll().filter(item => {\n      return item.data.tags && item.data.tags.includes('post');\n    });\n  });\n  \n  // Return configuration object\n  return {\n    dir: {\n      input: 'src',\n      output: 'dist',\n      includes: '_includes',\n      layouts: '_layouts',\n      data: '_data'\n    },\n    templateFormats: ['njk', 'md', 'html'],\n    markdownTemplateEngine: 'njk',\n    htmlTemplateEngine: 'njk',\n    dataTemplateEngine: 'njk'\n  };\n};\n```\n\n2. Update package.json scripts to use the TypeScript configuration:\n\n```json\n\"scripts\": {\n  \"build\": \"npm run build:ts && eleventy --config=.eleventy.ts\",\n  \"dev\": \"concurrently \\\"npm run dev:ts\\\" \\\"eleventy --config=.eleventy.ts --serve --watch\\\"\"\n}\n```\n\n3. Install required dependencies for Eleventy to work with TypeScript:\n\n```bash\nnpm install --save-dev ts-node @types/eleventy\n```\n\n4. Create a .eleventy.js wrapper file if needed for compatibility:\n\n```javascript\n// This file is just a wrapper to load the TypeScript configuration\nrequire('ts-node').register();\nmodule.exports = require('./.eleventy.ts');\n```",
        "testStrategy": "Test the Eleventy configuration by running a build with 'npx eleventy --config=.eleventy.ts'. Verify that all collections, filters, and other configuration options work as expected. Compare the output with the previous JavaScript-based build to ensure consistency. Check that all TypeScript types are properly resolved without any 'any' types.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Migrate Data Configuration Files to TypeScript",
        "description": "Convert site.js data file to TypeScript and create type definitions for JSON data files (i18n.json, certifications.json).",
        "details": "1. Convert site.js to site.ts:\n\n```typescript\n// src/_data/site.ts\ninterface SiteConfig {\n  title: string;\n  description: string;\n  url: string;\n  author: {\n    name: string;\n    email: string;\n  };\n  buildTime: Date;\n  [key: string]: any;\n}\n\nconst siteConfig: SiteConfig = {\n  title: 'Portfolio Website',\n  description: 'Personal portfolio and blog',\n  url: 'https://example.com',\n  author: {\n    name: 'Developer Name',\n    email: 'dev@example.com'\n  },\n  buildTime: new Date()\n};\n\nmodule.exports = siteConfig;\n```\n\n2. Create type definitions for JSON data files:\n\n```typescript\n// types/data.d.ts\nexport interface Certification {\n  title: string;\n  issuer: string;\n  date: string;\n  url?: string;\n  skills: string[];\n}\n\nexport interface I18nData {\n  languages: {\n    [code: string]: {\n      name: string;\n      nativeName: string;\n    };\n  };\n  defaultLanguage: string;\n}\n```\n\n3. Create TypeScript interfaces for frontmatter schemas:\n\n```typescript\n// types/frontmatter.d.ts\nexport interface PostFrontmatter {\n  title: string;\n  date: string;\n  tags: string[];\n  description?: string;\n  featured?: boolean;\n  image?: string;\n  lang: string;\n}\n\nexport interface PageFrontmatter {\n  title: string;\n  layout: string;\n  permalink: string;\n  lang: string;\n  [key: string]: any;\n}\n```\n\n4. Update the build process to handle TypeScript data files:\n\n```bash\nnpm install --save-dev @11ty/eleventy-plugin-typescript\n```\n\nAdd to .eleventy.ts:\n```typescript\nconst eleventyPluginTypescript = require('@11ty/eleventy-plugin-typescript');\neleventyConfig.addPlugin(eleventyPluginTypescript);\n```",
        "testStrategy": "Validate data files by running a build and checking that the data is correctly loaded into Eleventy. Create test templates that use the data to ensure it's properly typed and accessible. Verify that JSON data files are correctly typed by importing them in TypeScript files and checking for type errors.",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure Eleventy TypeScript Plugin",
            "description": "Install the necessary Eleventy plugin to process TypeScript data files and add it to the Eleventy configuration.",
            "dependencies": [],
            "details": "Run `npm install --save-dev @11ty/eleventy-plugin-typescript`. Then, edit the existing `.eleventy.ts` configuration file. Import the plugin using `import eleventyPluginTypescript from '@11ty/eleventy-plugin-typescript';` and register it within the main configuration function by adding `eleventyConfig.addPlugin(eleventyPluginTypescript);`. This will enable Eleventy to recognize and compile `.ts` files in the `_data` directory.",
            "status": "done",
            "testStrategy": "After installation and configuration, run the Eleventy build process. The build should complete without errors related to unrecognized `.ts` files, although it may fail later if the `site.ts` file is not yet created."
          },
          {
            "id": 2,
            "title": "Convert site.js Data File to site.ts",
            "description": "Migrate the existing `src/_data/site.js` file to a new TypeScript file `src/_data/site.ts`, including a corresponding interface for type safety.",
            "dependencies": [
              "5.1"
            ],
            "details": "Create a new file `src/_data/site.ts`. Inside this file, define a `SiteConfig` interface based on the structure of the existing `site.js`. Create a `siteConfig` constant typed with this interface, populating it with the data from `site.js`. Export the constant using `module.exports = siteConfig;`. Finally, delete the original `src/_data/site.js` file.",
            "status": "done",
            "testStrategy": "Run `npx @11ty/eleventy` and verify the build completes successfully. Inspect a generated HTML page that uses `site` data (e.g., in the footer or header) to confirm that the data from `site.ts` is correctly loaded and rendered."
          },
          {
            "id": 3,
            "title": "Create Type Definitions for JSON Data Files",
            "description": "Create a new declaration file to define TypeScript interfaces for the `certifications.json` and `i18n.json` data files.",
            "dependencies": [],
            "details": "Create a new directory `types`. Inside it, create a file named `data.d.ts`. In this file, define and export an `I18nData` interface matching the structure of `src/_data/i18n.json`. Also, define and export a `Certification` interface for the objects within the `src/_data/certifications.json` array. The full type for the certifications data will be `Certification[]`.",
            "status": "done",
            "testStrategy": "This subtask only creates type definitions, so direct testing is not applicable. Verification will occur in subtask 5 when these types are used to type-check data within the application."
          },
          {
            "id": 4,
            "title": "Create Type Definitions for Frontmatter Schemas",
            "description": "Create a new declaration file to define TypeScript interfaces for common frontmatter schemas used in posts and pages.",
            "dependencies": [],
            "details": "Create a new file `types/frontmatter.d.ts`. In this file, define and export a `PostFrontmatter` interface for blog posts and a `PageFrontmatter` interface for general content pages. These interfaces should include common fields like `title`, `date`, `tags`, `layout`, and `lang` as specified in the task description.",
            "status": "done",
            "testStrategy": "Similar to subtask 3, this only creates type definitions. Verification will happen when these interfaces are imported and used to type Eleventy collections or frontmatter data in `.eleventy.ts` or other utility files."
          },
          {
            "id": 5,
            "title": "Update tsconfig.json and Verify Type Integration",
            "description": "Update the `tsconfig.json` to include the new TypeScript files and types, then verify that the new types are correctly applied and recognized by the toolchain.",
            "dependencies": [
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "Modify the `include` array in `tsconfig.json` to add `'src/_data/**/*.ts'` and `'types/**/*.d.ts'`. To verify, open `.eleventy.ts` and import one of the newly created types, for example, `import { PostFrontmatter } from './types/frontmatter';`. Use this type within a collection definition, such as `eleventyConfig.addCollection('posts', collectionApi => { const posts = collectionApi.getFilteredByTag('post'); return posts.map(post => { const typedData = post.data as PostFrontmatter; /* ... */ }); });`. Running `tsc --noEmit` should pass without errors.",
            "status": "done",
            "testStrategy": "Run `npx tsc --noEmit` to confirm that the TypeScript compiler can find and correctly parse all new files and type definitions without emitting any errors. Run a full Eleventy build to ensure the changes haven't introduced any runtime issues."
          }
        ]
      },
      {
        "id": 6,
        "title": "Convert Client-Side JavaScript to TypeScript",
        "description": "Migrate browser-side JavaScript files to TypeScript with proper DOM type definitions and event handling types.",
        "details": "1. Update the tsconfig.json to include client-side files:\n\n```json\n{\n  \"compilerOptions\": {\n    // Existing options...\n    \"lib\": [\"DOM\", \"DOM.Iterable\", \"ESNext\"],\n    \"outDir\": \"dist/assets/js\"\n  },\n  \"include\": [\n    // Existing includes...\n    \"public/assets/js/**/*\"\n  ]\n}\n```\n\n2. Convert each client-side JavaScript file to TypeScript. Example:\n\n```typescript\n// public/assets/js/navigation.ts\ninterface NavigationOptions {\n  menuSelector: string;\n  toggleSelector: string;\n  activeClass: string;\n}\n\nclass Navigation {\n  private menu: HTMLElement | null;\n  private toggle: HTMLElement | null;\n  private activeClass: string;\n  \n  constructor(options: NavigationOptions) {\n    this.menu = document.querySelector(options.menuSelector);\n    this.toggle = document.querySelector(options.toggleSelector);\n    this.activeClass = options.activeClass;\n    \n    this.init();\n  }\n  \n  private init(): void {\n    if (!this.menu || !this.toggle) return;\n    \n    this.toggle.addEventListener('click', this.toggleMenu.bind(this));\n  }\n  \n  private toggleMenu(event: MouseEvent): void {\n    event.preventDefault();\n    this.menu?.classList.toggle(this.activeClass);\n  }\n}\n\n// Initialize navigation when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  new Navigation({\n    menuSelector: '.nav-menu',\n    toggleSelector: '.nav-toggle',\n    activeClass: 'is-active'\n  });\n});\n```\n\n3. Set up a build process for client-side TypeScript:\n\n```json\n// package.json scripts\n\"scripts\": {\n  \"build:client-ts\": \"tsc -p tsconfig.client.json\",\n  \"dev:client-ts\": \"tsc -p tsconfig.client.json --watch\"\n}\n```\n\n4. Create a separate tsconfig.client.json for client-side code if needed:\n\n```json\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"target\": \"ES2015\",\n    \"module\": \"ESNext\",\n    \"outDir\": \"public/assets/js\"\n  },\n  \"include\": [\"src/client/**/*.ts\"]\n}\n```\n\n5. Update HTML templates to reference the compiled JavaScript files.",
        "testStrategy": "Test client-side TypeScript by running the build process and checking that the JavaScript files are correctly generated. Manually test the website in different browsers to ensure all interactive features work as expected. Use browser developer tools to check for any JavaScript errors. Consider adding automated browser tests with tools like Cypress or Playwright to verify client-side functionality.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Client-Side TypeScript Configuration and Build Scripts",
            "description": "Create a dedicated tsconfig file for client-side code, establish a source directory for TypeScript files, and add the necessary build and watch scripts to package.json.",
            "dependencies": [],
            "details": "1. Create a new directory `src/client` to house the client-side TypeScript source files.\n2. Create a `tsconfig.client.json` file in the project root with a configuration optimized for browsers. This file should extend the base `tsconfig.json` but override `target`, `module`, and `outDir`.\n```json\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"target\": \"ES2015\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"DOM\", \"DOM.Iterable\", \"ESNext\"],\n    \"outDir\": \"public/assets/js\",\n    \"rootDir\": \"src/client\"\n  },\n  \"include\": [\"src/client/**/*.ts\"]\n}\n```\n3. Update `package.json` to add scripts for compiling the client-side TypeScript.\n```json\n\"scripts\": {\n  // ... existing scripts\n  \"build:client\": \"tsc -p tsconfig.client.json\",\n  \"watch:client\": \"tsc -p tsconfig.client.json --watch\"\n}\n```",
            "status": "done",
            "testStrategy": "Run `npm run build:client` and verify that the `public/assets/js` directory is created (if it doesn't exist) and that no errors are reported. Since there are no TS files yet, this will just validate the configuration."
          },
          {
            "id": 2,
            "title": "Migrate `main.js` to `src/client/main.ts`",
            "description": "Move the existing `main.js` logic to a new TypeScript file, `src/client/main.ts`, and apply strong types for DOM elements and events related to navigation.",
            "dependencies": [
              "6.1"
            ],
            "details": "1. Create the file `src/client/main.ts`.\n2. Copy the content from `public/assets/js/main.js` into the new file.\n3. Convert the JavaScript code to TypeScript. Use type assertions or guards to ensure DOM elements are not null.\n```typescript\n// src/client/main.ts\ndocument.addEventListener('DOMContentLoaded', () => {\n  const navToggle = document.querySelector<HTMLButtonElement>('.nav-toggle');\n  const navMenu = document.querySelector<HTMLElement>('.nav-menu');\n\n  if (navToggle && navMenu) {\n    navToggle.addEventListener('click', (e: MouseEvent) => {\n      e.preventDefault();\n      navMenu.classList.toggle('is-active');\n      navToggle.classList.toggle('is-active');\n    });\n  }\n});\n```\n4. The original `public/assets/js/main.js` should be removed after migration is complete in a later subtask, but can be kept for reference for now.",
            "status": "done",
            "testStrategy": "Run `npm run build:client`. Verify that `public/assets/js/main.js` is generated without any TypeScript errors. Open the website and confirm that the mobile navigation toggle works as expected."
          },
          {
            "id": 3,
            "title": "Migrate `theme-switcher.js` to `src/client/theme-switcher.ts`",
            "description": "Move the theme switching logic to a new TypeScript file, `src/client/theme-switcher.ts`, and add types for the theme switcher input element, its event, and interactions with localStorage.",
            "dependencies": [
              "6.1"
            ],
            "details": "1. Create the file `src/client/theme-switcher.ts`.\n2. Copy the content from `public/assets/js/theme-switcher.js` into the new file.\n3. Convert the IIFE to a modern TypeScript module or a simple script scope. Add appropriate types.\n```typescript\n// src/client/theme-switcher.ts\nconst themeSwitcher = document.querySelector<HTMLInputElement>('[data-theme-switcher]');\n\nif (themeSwitcher) {\n  const currentTheme = localStorage.getItem('theme') ?? 'light';\n  document.documentElement.setAttribute('data-theme', currentTheme);\n  themeSwitcher.checked = currentTheme === 'dark';\n\n  themeSwitcher.addEventListener('change', (e: Event) => {\n    const target = e.target as HTMLInputElement;\n    const theme = target.checked ? 'dark' : 'light';\n    document.documentElement.setAttribute('data-theme', theme);\n    localStorage.setItem('theme', theme);\n  });\n}\n```",
            "status": "done",
            "testStrategy": "Run `npm run build:client`. Check that `public/assets/js/theme-switcher.js` is generated. Open the website, test the theme switcher toggle, and verify that the theme persists across page reloads by checking `localStorage` in the browser's developer tools."
          },
          {
            "id": 4,
            "title": "Integrate Client-Side Build into Eleventy Workflow",
            "description": "Update the main `build` and `start` scripts in `package.json` to automatically compile client-side TypeScript as part of the Eleventy development and production build processes.",
            "dependencies": [
              "6.1"
            ],
            "details": "1. Install `npm-run-all` to run scripts concurrently and sequentially.\n`npm install npm-run-all --save-dev`\n2. Modify the `start` and `build` scripts in `package.json` to incorporate the client-side TypeScript compilation.\n```json\n\"scripts\": {\n  \"start\": \"npm-run-all --parallel watch:*\",\n  \"watch:eleventy\": \"eleventy --serve\",\n  \"watch:client\": \"tsc -p tsconfig.client.json --watch\",\n  \"build\": \"npm-run-all build:client build:eleventy\",\n  \"build:eleventy\": \"eleventy\",\n  \"build:client\": \"tsc -p tsconfig.client.json\",\n  \"type-check\": \"tsc --noEmit\"\n}\n```\nThis ensures that client-side TypeScript is watched for changes during development and built before the production Eleventy build.",
            "status": "done",
            "testStrategy": "Run `npm start`. Make a change to a `.ts` file in `src/client/` and verify that the `tsc` watcher recompiles it. Run `npm run build` and verify that both the client-side assets and the Eleventy site are built correctly."
          },
          {
            "id": 5,
            "title": "Finalize Integration and Clean Up Project",
            "description": "Ensure HTML templates reference the compiled JavaScript files, remove the original source JavaScript files from the `public` directory, and update `.gitignore`.",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "1. Verify that the `<script>` tags in `src/_includes/layouts/base.njk` (or other relevant templates) correctly point to the compiled files in `/assets/js/` (e.g., `<script src=\"/assets/js/main.js\" defer></script>`). No changes should be needed if the output filenames are the same.\n2. Delete the original JavaScript source files from `public/assets/js/` that have now been migrated to `src/client/` (e.g., `public/assets/js/main.js`, `public/assets/js/theme-switcher.js`). The directory `public/assets/js` should now be considered a build target.\n3. Add the client-side build output directory to `.gitignore` to prevent compiled files from being committed to version control.\n```\n# .gitignore\n\n# Build output\n/public/assets/js/\n```",
            "status": "done",
            "testStrategy": "After running `npm run build`, delete the `public/assets/js` directory and run `npm run build` again to ensure it's fully regenerated. Check the git status to confirm that the generated `public/assets/js` files are ignored. Perform a final manual test of the deployed site to ensure all functionality is intact."
          }
        ]
      },
      {
        "id": 7,
        "title": "Integrate TypeScript with Tailwind CSS Configuration",
        "description": "Configure Tailwind CSS to work with TypeScript files and update the build process for integrated compilation.",
        "details": "1. Convert tailwind.config.js to tailwind.config.ts:\n\n```typescript\n// tailwind.config.ts\nimport type { Config } from 'tailwindcss';\n\nconst config: Config = {\n  content: [\n    './src/**/*.{html,njk,md,ts,js}',\n    './public/assets/js/**/*.ts'\n  ],\n  theme: {\n    extend: {\n      // Your theme extensions\n    },\n  },\n  plugins: [\n    // Your plugins\n  ],\n};\n\nexport default config;\n```\n\n2. Install required dependencies:\n\n```bash\nnpm install --save-dev @types/tailwindcss\n```\n\n3. Update PostCSS configuration if needed:\n\n```typescript\n// postcss.config.ts\nexport default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n```\n\n4. Create a CSS processing script that works with TypeScript:\n\n```typescript\n// scripts/build-css.ts\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport postcss from 'postcss';\nimport tailwindcss from 'tailwindcss';\nimport autoprefixer from 'autoprefixer';\n\nasync function buildCss() {\n  const inputFile = path.resolve(__dirname, '../src/assets/css/main.css');\n  const outputFile = path.resolve(__dirname, '../dist/assets/css/main.css');\n  \n  const css = fs.readFileSync(inputFile, 'utf-8');\n  \n  const result = await postcss([\n    tailwindcss,\n    autoprefixer\n  ]).process(css, {\n    from: inputFile,\n    to: outputFile\n  });\n  \n  fs.mkdirSync(path.dirname(outputFile), { recursive: true });\n  fs.writeFileSync(outputFile, result.css);\n  \n  console.log('CSS built successfully');\n}\n\nbuildCss().catch(error => {\n  console.error('Error building CSS:', error);\n  process.exit(1);\n});\n```\n\n5. Update package.json scripts to include CSS processing:\n\n```json\n\"scripts\": {\n  \"build:css\": \"ts-node scripts/build-css.ts\",\n  \"dev:css\": \"npm run build:css -- --watch\",\n  \"build\": \"npm run build:ts && npm run build:css && npm run build:eleventy\"\n}\n```",
        "testStrategy": "Test the Tailwind CSS integration by running the build process and verifying that CSS is correctly generated with all the expected Tailwind utilities. Check that the CSS correctly processes classes used in TypeScript files. Verify that the watch mode works correctly during development. Test the final output in different browsers to ensure CSS is applied correctly.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Set Up Incremental Compilation for Development Workflow",
        "description": "Configure TypeScript for incremental compilation and implement a development workflow with hot reloading.",
        "details": "1. Update tsconfig.json to enable incremental compilation:\n\n```json\n{\n  \"compilerOptions\": {\n    // Existing options...\n    \"incremental\": true,\n    \"tsBuildInfoFile\": \".tsbuildinfo\",\n    \"composite\": true\n  }\n}\n```\n\n2. Install development dependencies for hot reloading:\n\n```bash\nnpm install --save-dev browser-sync concurrently nodemon\n```\n\n3. Create a development script that coordinates all processes:\n\n```typescript\n// scripts/dev.ts\nimport { spawn } from 'child_process';\nimport * as browserSync from 'browser-sync';\n\n// Start TypeScript compiler in watch mode\nconst tsc = spawn('npx', ['tsc', '--watch'], { stdio: 'inherit' });\n\n// Start Eleventy in watch mode\nconst eleventy = spawn('npx', ['eleventy', '--config=.eleventy.ts', '--serve', '--quiet'], { stdio: 'inherit' });\n\n// Start Tailwind CSS in watch mode\nconst tailwind = spawn('npx', ['tailwindcss', '-i', 'src/assets/css/main.css', '-o', 'dist/assets/css/main.css', '--watch'], { stdio: 'inherit' });\n\n// Initialize Browser-Sync\nconst bs = browserSync.create();\nbs.init({\n  proxy: 'localhost:8080', // Eleventy's default port\n  files: ['dist/**/*'],\n  open: false,\n  notify: false\n});\n\n// Handle process termination\nprocess.on('SIGINT', () => {\n  tsc.kill();\n  eleventy.kill();\n  tailwind.kill();\n  bs.exit();\n  process.exit();\n});\n```\n\n4. Update package.json scripts:\n\n```json\n\"scripts\": {\n  \"dev\": \"ts-node scripts/dev.ts\",\n  \"build\": \"tsc && eleventy --config=.eleventy.ts && tailwindcss -i src/assets/css/main.css -o dist/assets/css/main.css\"\n}\n```\n\n5. Configure nodemon for automatic server restart:\n\n```json\n// nodemon.json\n{\n  \"watch\": [\".eleventy.ts\", \"src/**/*.ts\", \"!src/client/**/*.ts\"],\n  \"ext\": \"ts,json\",\n  \"exec\": \"eleventy --config=.eleventy.ts\"\n}\n```",
        "testStrategy": "Test the development workflow by running 'npm run dev' and verifying that changes to TypeScript files trigger recompilation. Make changes to different types of files (templates, TypeScript utilities, CSS) and confirm that the browser automatically refreshes with the changes. Measure build times to ensure incremental compilation is working efficiently. Test the workflow on different operating systems if applicable.",
        "priority": "medium",
        "dependencies": [
          1,
          4,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement TypeScript Integration with Test Suite",
        "description": "Update test scripts to work with TypeScript and integrate type checking into the test suite.",
        "details": "1. Install testing dependencies:\n\n```bash\nnpm install --save-dev jest ts-jest @types/jest\n```\n\n2. Create Jest configuration for TypeScript:\n\n```typescript\n// jest.config.ts\nimport type { Config } from '@jest/types';\n\nconst config: Config.InitialOptions = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  transform: {\n    '^.+\\\\.ts$': 'ts-jest'\n  },\n  moduleFileExtensions: ['ts', 'js', 'json'],\n  collectCoverage: true,\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov']\n};\n\nexport default config;\n```\n\n3. Update existing test files to use TypeScript:\n\n```typescript\n// src/utils/__tests__/dates.test.ts\nimport { formatDate, isValidDate } from '../dates';\n\ndescribe('Date utilities', () => {\n  test('formatDate formats dates correctly', () => {\n    const date = new Date('2023-01-15');\n    expect(formatDate(date, { format: 'yyyy-MM-dd' })).toBe('2023-01-15');\n    expect(formatDate('2023-01-15', { format: 'MM/dd/yyyy' })).toBe('01/15/2023');\n  });\n\n  test('isValidDate validates dates correctly', () => {\n    expect(isValidDate(new Date('2023-01-15'))).toBe(true);\n    expect(isValidDate(new Date('invalid'))).toBe(false);\n    expect(isValidDate('not a date')).toBe(false);\n  });\n});\n```\n\n4. Create a script to run type checking as part of the test process:\n\n```typescript\n// scripts/test-with-types.ts\nimport { execSync } from 'child_process';\n\ntry {\n  // Run type checking\n  console.log('Running type checking...');\n  execSync('npx tsc --noEmit', { stdio: 'inherit' });\n  \n  // Run tests if type checking passes\n  console.log('\\nRunning tests...');\n  execSync('npx jest', { stdio: 'inherit' });\n} catch (error) {\n  process.exit(1);\n}\n```\n\n5. Update package.json scripts:\n\n```json\n\"scripts\": {\n  \"test\": \"ts-node scripts/test-with-types.ts\",\n  \"test:unit\": \"jest\",\n  \"test:types\": \"tsc --noEmit\"\n}\n```\n\n6. Set up CI integration in a .github/workflows/ci.yml file (if using GitHub Actions):\n\n```yaml\nname: CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm ci\n    - run: npm run test:types\n    - run: npm run test:unit\n    - run: npm run build\n```",
        "testStrategy": "Run the test suite with 'npm test' and verify that both type checking and unit tests are executed. Introduce intentional type errors and test failures to confirm that the process correctly identifies and reports issues. Check that test coverage reports are generated correctly. Verify that the CI configuration works by pushing to a test branch or creating a pull request.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Finalize Migration and Documentation",
        "description": "Complete the TypeScript migration by ensuring all files are converted, update documentation, and perform final testing and optimization.",
        "details": "1. Create a TypeScript migration checklist and verify all files have been converted:\n\n```typescript\n// scripts/migration-status.ts\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as glob from 'glob';\n\ninterface FileStatus {\n  path: string;\n  converted: boolean;\n}\n\nfunction checkMigrationStatus() {\n  const jsFiles = glob.sync('src/**/*.js').map(file => ({\n    path: file,\n    converted: fs.existsSync(file.replace('.js', '.ts'))\n  }));\n  \n  const unconverted = jsFiles.filter(file => !file.converted);\n  \n  console.log(`Migration Status: ${jsFiles.length - unconverted.length}/${jsFiles.length} files converted`);\n  \n  if (unconverted.length > 0) {\n    console.log('\\nFiles still needing conversion:');\n    unconverted.forEach(file => console.log(`- ${file.path}`));\n  } else {\n    console.log('\\nAll files have been converted to TypeScript!');\n  }\n}\n\ncheckMigrationStatus();\n```\n\n2. Update project documentation:\n\n- Create a MIGRATION.md file documenting the TypeScript migration process\n- Update README.md with TypeScript-specific information\n- Add JSDoc comments to key functions and interfaces\n- Document any breaking changes or API modifications\n\n3. Perform final optimization:\n\n```typescript\n// scripts/optimize.ts\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { execSync } from 'child_process';\n\n// Run type checking with --noImplicitAny to find any remaining 'any' types\ntry {\n  execSync('npx tsc --noImplicitAny', { stdio: 'inherit' });\n  console.log('No implicit any types found!');\n} catch (error) {\n  console.error('Found implicit any types that should be fixed');\n}\n\n// Check bundle sizes\nconst jsDir = path.resolve(__dirname, '../dist/assets/js');\nconst jsFiles = fs.readdirSync(jsDir).filter(file => file.endsWith('.js'));\n\nconsole.log('\\nJavaScript bundle sizes:');\njsFiles.forEach(file => {\n  const stats = fs.statSync(path.join(jsDir, file));\n  console.log(`- ${file}: ${(stats.size / 1024).toFixed(2)} KB`);\n});\n```\n\n4. Create a final verification script:\n\n```typescript\n// scripts/verify-build.ts\nimport { execSync } from 'child_process';\n\nconsole.log('Running full verification...');\n\ntry {\n  // Clean previous build\n  execSync('rm -rf dist', { stdio: 'inherit' });\n  \n  // Run type checking\n  console.log('\\nVerifying types...');\n  execSync('npm run test:types', { stdio: 'inherit' });\n  \n  // Run tests\n  console.log('\\nRunning tests...');\n  execSync('npm run test:unit', { stdio: 'inherit' });\n  \n  // Build project\n  console.log('\\nBuilding project...');\n  execSync('npm run build', { stdio: 'inherit' });\n  \n  console.log('\\n Verification complete! The TypeScript migration was successful.');\n} catch (error) {\n  console.error('\\n Verification failed. Please fix the issues before considering the migration complete.');\n  process.exit(1);\n}\n```\n\n5. Update package.json scripts:\n\n```json\n\"scripts\": {\n  \"migration:status\": \"ts-node scripts/migration-status.ts\",\n  \"migration:verify\": \"ts-node scripts/verify-build.ts\",\n  \"optimize\": \"ts-node scripts/optimize.ts\"\n}\n```",
        "testStrategy": "Run the migration status script to verify all files have been converted. Execute the verification script to perform a complete build and test cycle. Check documentation for accuracy and completeness. Perform manual testing of the website to ensure all features work correctly. Compare performance metrics before and after the migration to ensure there's no regression. Get feedback from other developers on the team about the TypeScript implementation.",
        "priority": "low",
        "dependencies": [
          3,
          4,
          5,
          6,
          7,
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Migration and Verification Helper Scripts",
            "description": "Create the `scripts/` directory and add the `migration-status.ts`, `optimize.ts`, and `verify-build.ts` files. Update `package.json` to include the corresponding `migration:status`, `optimize`, and `migration:verify` npm scripts.",
            "dependencies": [],
            "details": "Use the provided code snippets from the task description to create the three TypeScript helper scripts. Ensure `ts-node`, `glob`, and their associated types (`@types/node`, `@types/glob`) are listed as dev dependencies in `package.json` to allow these scripts to run correctly via npm.",
            "status": "done",
            "testStrategy": "Run `npm run migration:status`, `npm run optimize`, and `npm run migration:verify` individually. Verify that each script executes without crashing, even if they report errors (like unconverted files or type issues), confirming the `package.json` setup is correct."
          },
          {
            "id": 2,
            "title": "Migrate Eleventy Config and Remaining JS Files to TypeScript",
            "description": "Convert the main Eleventy configuration file `.eleventy.js` to `.eleventy.ts` and migrate any other remaining JavaScript files within the `src` directory. This includes ensuring the build process correctly handles any client-side TypeScript files.",
            "dependencies": [],
            "details": "Rename `.eleventy.js` to `.eleventy.ts` and update its syntax from CommonJS (`require`/`module.exports`) to ES Modules (`import`/`export default`). Add type annotations for the Eleventy config function. Use the `migration:status` script created in the previous subtask to find and convert any other lingering `.js` files in `src`.",
            "status": "done",
            "testStrategy": "Run `npm start` or `npm run build` to confirm that Eleventy can correctly read and execute the new `.eleventy.ts` configuration file. Run `npm run migration:status` and verify that it reports 0 files still needing conversion."
          },
          {
            "id": 3,
            "title": "Execute Optimization Script and Eliminate Implicit 'any' Types",
            "description": "Run the `npm run optimize` script to identify all instances of implicit `any` types throughout the codebase. Refactor the code to provide explicit types for all identified cases, improving type safety and code clarity.",
            "dependencies": [
              "10.1",
              "10.2"
            ],
            "details": "Execute `npx tsc --noImplicitAny` or the `npm run optimize` script. For each error reported, navigate to the file and add the appropriate type definition. This may involve creating or updating interfaces in the `types/` directory or using utility types. Repeat this process until the script completes successfully.",
            "status": "done",
            "testStrategy": "Run `npm run optimize` and ensure it exits with a success code and logs 'No implicit any types found!'. Also, check the bundle size output for any significant, unexpected increases that might indicate a problem with the build configuration."
          },
          {
            "id": 4,
            "title": "Create MIGRATION.md and Update Project Documentation",
            "description": "Create a new `MIGRATION.md` file documenting the TypeScript migration process. Update the main `README.md` to reflect the new TypeScript-based development workflow, including setup, build, and testing commands.",
            "dependencies": [
              "10.1"
            ],
            "details": "In `MIGRATION.md`, describe the steps taken, the rationale for the migration, and how to use the new helper scripts (`migration:status`, `optimize`, `migration:verify`). In `README.md`, update the 'Getting Started' and 'Available Scripts' sections to replace JavaScript-centric instructions with the new TypeScript equivalents (e.g., `npm run test:types`).",
            "status": "done",
            "testStrategy": "Review the `MIGRATION.md` and `README.md` files for clarity, accuracy, and completeness. Ask a team member to follow the setup instructions in the updated `README.md` on a fresh clone of the repository to ensure they are correct."
          },
          {
            "id": 5,
            "title": "Add JSDoc Comments and Perform Final Verification",
            "description": "Enhance code documentation by adding JSDoc comments to key functions, interfaces, and types, particularly in `.eleventy.ts`, data files, and utilities. Finally, execute the `npm run migration:verify` script to perform a full clean, build, and test cycle to confirm the migration's success.",
            "dependencies": [
              "10.2",
              "10.3"
            ],
            "details": "Go through critical files and add JSDoc blocks explaining the purpose, parameters (`@param`), and return values (`@returns`) of functions and properties. After documenting, run `npm run migration:verify`. This script will clean the `dist` directory, run the type checker, execute unit tests, and perform a production build, serving as a final quality gate.",
            "status": "done",
            "testStrategy": "Verify that `npm run migration:verify` completes without any errors. After a successful run, manually browse the generated site from the `dist` folder or by using a local server to ensure all pages render correctly and all functionality is intact. Check the browser's developer console for any runtime errors."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-13T04:08:00.503Z",
      "updated": "2025-09-13T22:59:40.931Z",
      "description": "Tasks for typescript-implement context"
    }
  },
  "alpha-version": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Repository Configuration",
        "description": "Initialize the project repository with the basic structure and configuration files needed for development.",
        "details": "1. Create a new repository at github.com/yokharian/portfolio\n2. Initialize the project with package.json\n3. Set up Tailwind CSS configuration\n4. Configure a static site generator (Astro or 11ty recommended based on Markdown requirements)\n5. Create the basic folder structure:\n   - src/\n     - pages/\n     - layouts/\n     - components/\n     - styles/\n   - public/\n     - images/\n   - content/\n     - projects/\n6. Set up Git hooks for code quality\n7. Create a README.md with project documentation\n<info added on 2025-09-12T17:53:07.892Z>\n## Implementation Details\n\nEleventy (11ty) has been implemented as the static site generator with the following configuration:\n\n### Project Structure\n- `.eleventy.js`: Configured with passthrough copy for /public, directory structure (input: \".\", includes/layouts in src/layouts, data in src/data, output to _site), and a \"posts\" collection from blog_posts/**/*.md\n- `.eleventyignore`: Excludes node_modules, _site, .taskmaster, UI_UX_GUIDE\n- `tailwind.config.js`: Scans **/*.{html,njk,md} files with appropriate exclusions\n- `src/layouts/base.njk`: Base HTML template with CSS link\n- `src/pages/index.njk`: Homepage that lists posts from the \"posts\" collection\n- `src/styles/tailwind.css`: Tailwind entry point with base/components/utilities\n- `public/assets/.gitkeep` and `public/images/.gitkeep`: Placeholder files for static assets\n\n### Package Configuration\n- `package.json`: Includes development scripts:\n  - `dev`: Runs 11ty in serve mode with Tailwind watch\n  - `build`: Full production build\n  - `build:css`: Tailwind CSS compilation\n  - `clean`: Removes build artifacts\n- Dependencies: @11ty/eleventy, tailwindcss, postcss, autoprefixer, npm-run-all, rimraf\n\n### Documentation\n- `README.md`: Contains quick start guide, project structure explanation, and next steps\n\n### Pending Items\n- Git hooks setup (awaiting preference on husky/lint-staged)\n- Additional structure components (src/components, content/projects)\n- Confirmation needed on 11ty as the chosen SSG (vs Astro)\n</info added on 2025-09-12T17:53:07.892Z>\n<info added on 2025-09-12T17:55:49.670Z>\n## Implementation Update: 11ty Core Features\n\n### New Components Added\n- `src/data/site.json`: Central configuration for site constants including:\n  - Contact information (Calendly URL, GitHub, LinkedIn, email)\n  - Site titles and default meta description\n  - Other global variables for templates\n\n- `src/layouts/base.njk`: Enhanced with:\n  - Header featuring Sofia Escobedo's name\n  - Primary CTA button linking to Calendly\n  - Social media links (GitHub, LinkedIn)\n  - SEO meta tags for title and description\n  - Improved footer with contact information\n\n- `src/layouts/post.njk`: Project template with:\n  - Banner image display\n  - Employer and date information\n  - Technology tags display\n  - Lazy-loaded images for performance\n  - Tailwind prose styling for Markdown content\n\n- `blog_posts/posts.json`: Directory data file that:\n  - Applies post.njk as default layout for all Markdown files in blog_posts/\n\n### Progress Notes\n- Homepage now lists posts from the 11ty collection\n- Pending implementation:\n  - Featured Work section with hover effects (FR7-FR9)\n  - SEO enhancements\n  - Language switching functionality (FR5)\n  - Need specification on pairing English/Spanish content\n\n### Verification Steps\n1. npm install\n2. npm run dev (http://localhost:8080) or npm run build (check _site/)\n3. Verify blog_posts/*.md render with new layout and header/footer display CTA and links\n</info added on 2025-09-12T17:55:49.670Z>\n<info added on 2025-09-12T19:07:52.244Z>\n## Implementation Completion Update\n\n### Git Hooks Configuration\n- Implemented Husky for Git hooks management\n- Added pre-commit hook that runs `npm run build` to ensure code quality\n- Updated package.json with `prepare` script for automatic hooks installation\n\n### Directory Structure Completion\n- Created placeholder directories:\n  - `src/components/` for reusable UI components\n  - `content/projects/` for project content files\n\n### Documentation & Verification\n- README.md updated with quick start guide and project structure\n- Git hooks automatically activate upon `npm install`\n- Build scripts verified and working correctly\n\n### Status Update\n- All initial setup requirements completed\n- 11ty confirmed as the chosen static site generator\n- Project ready for downstream tasks (content creation and template development)\n</info added on 2025-09-12T19:07:52.244Z>",
        "testStrategy": "Verify that the repository is properly initialized with all configuration files. Test the build process to ensure it correctly processes Markdown files and generates static HTML. Confirm that Tailwind CSS is properly configured by testing a simple component with Tailwind classes.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure homepage site at root",
            "description": "Visitors shouldn't follow a complex directory structure. There are only two allowed levels: /<homepage> and /blog/<post>",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Base Layout Components",
        "description": "Create the base layout components that will be used across all pages, including header and footer with required links.",
        "details": "1. Create a main layout component that includes:\n   - HTML5 boilerplate with proper meta tags\n   - Responsive viewport settings\n   - Tailwind CSS imports\n2. Implement the header component with:\n   - Sofia Escobedo's name as per FR2\n   - Primary CTA button 'Agendar llamada de 30 min' linking to Calendly (FR3)\n   - Language switcher (FR5)\n3. Implement the footer component with:\n   - Links to GitHub, LinkedIn profiles\n   - Calendly link\n   - Email contact (mailto: link)\n   - Copyright information\n4. Create a responsive navigation system\n5. Implement language switching functionality (English/Spanish toggle)",
        "testStrategy": "Test the layout components in different viewport sizes to ensure responsiveness. Verify that all links in the header and footer are working correctly. Test the language switcher to ensure it properly changes the displayed language. Validate HTML structure for accessibility and SEO best practices.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create base.njk layout template",
            "description": "Implement the main layout template that will serve as the foundation for all pages, including proper HTML5 structure and metadata.",
            "dependencies": [],
            "details": "Create src/_includes/layouts/base.njk with: 1) HTML5 doctype and structure, 2) <head> section with meta charset, viewport settings, title tag using {{ title }} variable with fallback, 3) link to /assets/styles.css for Tailwind, 4) lang attribute on <html> tag using {{ page.lang }} or site.defaultLanguage, 5) <body> with {% block content %}{% endblock %} for page-specific content.",
            "status": "done",
            "testStrategy": "Validate HTML structure using W3C validator. Test with different viewport sizes to verify responsive meta tag. Verify CSS is properly linked by checking styles are applied."
          },
          {
            "id": 2,
            "title": "Implement header partial with navigation",
            "description": "Create a responsive header component with site title, primary CTA button, and language switcher UI.",
            "dependencies": [],
            "details": "Create src/_includes/partials/header.njk containing: 1) Site title 'Sofia Escobedo' as main heading, 2) Primary CTA button with text 'Agendar llamada de 30 min' linking to a Calendly URL (use {{ site.calendlyUrl }} from data file), 3) Basic navigation menu with responsive design, 4) Language switcher with EN/ES options (stub links for now, full functionality in Task 10).",
            "status": "done",
            "testStrategy": "Test header display at multiple viewport sizes. Verify CTA button links to correct Calendly URL. Check that language switcher options are visible."
          },
          {
            "id": 3,
            "title": "Implement footer partial with social links",
            "description": "Create a footer component with social media links, contact information, and copyright notice.",
            "dependencies": [],
            "details": "Create src/_includes/partials/footer.njk containing: 1) Social media links to GitHub and LinkedIn using {{ site.githubUrl }} and {{ site.linkedinUrl }} from data files, 2) Calendly link using {{ site.calendlyUrl }}, 3) Email contact using mailto: with {{ site.email }}, 4) Copyright information with dynamic year using {% year = new Date().getFullYear() %} and site owner name.",
            "status": "done",
            "testStrategy": "Verify all links in footer point to correct URLs. Test mailto link functionality. Check that current year is displayed correctly in copyright notice."
          },
          {
            "id": 4,
            "title": "Create site data configuration files",
            "description": "Set up data files to store site-wide configuration and variables used in layout components.",
            "dependencies": [],
            "details": "Create src/_data/site.json with the following properties: 1) title: 'Sofia Escobedo', 2) description: 'Python AWS Developer', 3) defaultLanguage: 'en', 4) githubUrl: 'https://github.com/yourusername' (placeholder), 5) linkedinUrl: 'https://linkedin.com/in/yourusername' (placeholder), 6) calendlyUrl: 'https://calendly.com/yourusername' (placeholder), 7) email: 'your.email@example.com' (placeholder).",
            "status": "done",
            "testStrategy": "Verify data file is valid JSON. Test that values are correctly accessed in templates."
          },
          {
            "id": 5,
            "title": "Wire layouts and verify build process",
            "description": "Connect all layout components together, implement index page, and verify the build process works correctly.",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3",
              "2.4"
            ],
            "details": "1) Include header/footer in base.njk using {% include \"partials/header.njk\" %} and {% include \"partials/footer.njk\" %}, 2) Create src/index.njk that extends base.njk with {% extends \"layouts/base.njk\" %} and minimal content in {% block content %}, 3) Update package.json with build scripts if needed, 4) Run build process to generate _site directory, 5) Verify generated HTML contains all expected elements and correct structure.",
            "status": "done",
            "testStrategy": "Run build process and verify no errors. Check generated _site/index.html contains header, footer, and all links. Test page in browser to ensure layout displays correctly."
          }
        ]
      },
      {
        "id": 3,
        "title": "Develop Markdown Processing System",
        "description": "Create a system to process Markdown files with frontmatter for project content, extracting metadata and generating HTML pages.",
        "details": "1. Set up a Markdown parser with frontmatter support\n2. Create a schema for project frontmatter that includes:\n   - title\n   - description\n   - employer\n   - startDate\n   - endDate\n   - tags (technologies)\n   - heroImage\n   - language\n3. Implement a function to extract and validate frontmatter data\n4. Create a template for rendering project pages that includes:\n   - Hero banner with project image\n   - Metadata display section\n   - Main content area with proper typography\n   - 'Technologies Used' section generated from tags\n5. Implement the Markdown to HTML conversion process\n6. Set up the build process to generate a static HTML page for each Markdown file",
        "testStrategy": "Create test Markdown files with various frontmatter configurations to verify the extraction process. Test the rendering of Markdown content with different elements (headings, lists, code blocks, etc.). Verify that the generated HTML pages maintain the correct structure and styling. Test with both English and Spanish content to ensure proper language handling.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Markdown Parser with Frontmatter Support",
            "description": "Select and integrate a Markdown parser library that supports frontmatter extraction. Configure it with safe defaults for the project.",
            "dependencies": [],
            "details": "Research and select a suitable Markdown parser (recommend remark.js or gray-matter). Install the chosen library and create a utility module that exposes a function to parse Markdown content. Configure the parser with safe defaults for HTML sanitization and frontmatter extraction. Include error handling for malformed Markdown files.",
            "status": "done",
            "testStrategy": "Create test cases with valid and invalid Markdown files. Verify the parser correctly extracts frontmatter and converts Markdown to HTML. Test error handling with malformed inputs."
          },
          {
            "id": 2,
            "title": "Define Frontmatter Schema with Type Definitions",
            "description": "Create a schema for project frontmatter with proper type definitions, required/optional rules, and default values.",
            "dependencies": [
              "3.1"
            ],
            "details": "Define a TypeScript interface or schema object for frontmatter that includes: title (string, required), description (string, required), employer (string, optional), startDate (ISO date string, required), endDate (ISO date string, optional), tags (array of strings, required), heroImage (string path, required), language (string enum, required), slug (string, optional), featured (boolean, optional). Include documentation for each field and specify default values where appropriate.",
            "status": "done",
            "testStrategy": "Create test cases to validate the schema against various frontmatter examples. Verify required fields are enforced and optional fields have proper defaults."
          },
          {
            "id": 3,
            "title": "Implement Frontmatter Validation Function",
            "description": "Create a validation function that checks frontmatter data against the schema and provides helpful error messages.",
            "dependencies": [
              "3.2"
            ],
            "details": "Implement a validation function that takes extracted frontmatter data and validates it against the defined schema. Include checks for required fields, data types, and format validation (e.g., ISO dates). Generate helpful error messages that indicate which fields are missing or invalid. Provide sensible defaults for optional fields when not provided.",
            "status": "done",
            "testStrategy": "Test with valid frontmatter, missing required fields, invalid data types, and malformed dates. Verify error messages are clear and helpful."
          },
          {
            "id": 4,
            "title": "Implement Content Discovery System",
            "description": "Create a system to scan the content directory for Markdown files and build a collection of project data.",
            "dependencies": [
              "3.1",
              "3.3"
            ],
            "details": "Implement a function that recursively scans the content/projects/ directory (or similar) for Markdown files. For each file, extract and validate the frontmatter, storing the results in a collection. Include file path information and generate slugs based on filename or frontmatter. Handle errors gracefully, logging issues but continuing to process valid files.",
            "status": "done",
            "testStrategy": "Test with a directory containing multiple Markdown files, including some with invalid frontmatter. Verify all valid files are discovered and processed correctly."
          },
          {
            "id": 5,
            "title": "Enhance Markdown to HTML Conversion",
            "description": "Implement advanced Markdown to HTML conversion with support for code blocks, tables, images, and properly configured external links.",
            "dependencies": [
              "3.1"
            ],
            "details": "Extend the basic Markdown parser to support syntax highlighting for code blocks, properly formatted tables, responsive images, and external links that open in new tabs with appropriate rel attributes (noopener, noreferrer). Configure the parser to maintain heading hierarchy and generate anchor IDs for headings. Implement custom renderers for specific Markdown elements if needed.",
            "status": "done",
            "testStrategy": "Create test Markdown files with various elements (code blocks, tables, images, links). Verify the generated HTML includes proper syntax highlighting, responsive image attributes, and correctly configured external links."
          },
          {
            "id": 6,
            "title": "Create Project Page Template with Component Sections",
            "description": "Develop a template for project pages that includes hero image, metadata section, content area, and technology tags.",
            "dependencies": [
              "3.5"
            ],
            "details": "Create a template/layout for project pages that integrates with Task 7 (Project Page Template). Include sections for: hero image banner, project metadata display (title, dates, employer), main content area with proper typography (using Tailwind prose), and a 'Technologies Used' section generated from tags. Ensure the template is responsive and follows accessibility best practices.",
            "status": "done",
            "testStrategy": "Test the template with various project data to ensure all sections render correctly. Verify responsive behavior across different screen sizes. Check accessibility with automated tools."
          },
          {
            "id": 7,
            "title": "Implement Language Handling for Project Content",
            "description": "Add support for multilingual project content with language detection, fallbacks, and filtering.",
            "dependencies": [
              "3.4"
            ],
            "details": "Implement functionality to load the language field from frontmatter and support filtering collections by language. Create a system for language fallbacks when content isn't available in the requested language. Integrate with the site's language switching mechanism (if already implemented) to ensure project content changes appropriately when language is switched.",
            "status": "done",
            "testStrategy": "Test with projects in different languages. Verify language filtering works correctly. Test language switching to ensure content updates appropriately. Verify fallback behavior when content isn't available in the requested language."
          },
          {
            "id": 8,
            "title": "Develop Date Formatting and Handling System",
            "description": "Create utilities for parsing ISO dates, formatting them according to language preferences, and handling ongoing projects.",
            "dependencies": [
              "3.3"
            ],
            "details": "Implement utilities to parse ISO date strings from frontmatter. Create formatting functions that display dates according to language preferences (e.g., 'January 2022' vs 'Enero 2022'). Add special handling for ongoing projects (missing endDate) to display appropriate text (e.g., 'Present' or 'Actual'). Include relative time formatting options (e.g., '2 years ago').",
            "status": "done",
            "testStrategy": "Test date parsing with various formats. Verify formatting in different languages. Test handling of ongoing projects and edge cases like projects with same start/end dates."
          },
          {
            "id": 9,
            "title": "Implement Image Validation and Processing",
            "description": "Add validation for hero images, generate alt text, and support responsive image attributes.",
            "dependencies": [
              "3.3"
            ],
            "details": "Implement validation to ensure heroImage paths reference existing files. Generate default alt text from project titles if not explicitly provided. Add support for responsive image attributes (srcset, sizes) to optimize loading. Include image optimization as part of the build process to reduce file sizes while maintaining quality.",
            "status": "done",
            "testStrategy": "Test with valid and invalid image paths. Verify alt text generation. Test responsive image attributes on different devices. Measure image loading performance before and after optimization."
          },
          {
            "id": 10,
            "title": "Integrate with Build Process for Static HTML Generation",
            "description": "Set up the build process to generate a static HTML page for each Markdown file using the project template.",
            "dependencies": [
              "3.6",
              "3.7",
              "3.8",
              "3.9"
            ],
            "details": "Integrate the Markdown processing system with the static site generator's build process. For each processed Markdown file, generate a static HTML page using the project template. Create predictable permalinks/URLs based on slugs or file paths. Ensure all metadata and content are correctly passed to the template. Add build-time validation to catch any issues with content or frontmatter.",
            "status": "done",
            "testStrategy": "Run the build process with various Markdown files. Verify each generates a correctly formatted HTML page with proper URLs. Test the build process with invalid content to ensure appropriate error handling."
          },
          {
            "id": 11,
            "title": "Create Comprehensive Test Suite with Fixtures",
            "description": "Develop a test suite with fixtures for various frontmatter configurations, invalid inputs, and snapshot tests of rendered HTML.",
            "dependencies": [
              "3.10"
            ],
            "details": "Create a comprehensive test suite with fixtures representing different frontmatter variants (all required fields, optional fields, edge cases). Include tests for invalid inputs (missing required fields, wrong data types). Implement snapshot tests of rendered HTML to detect unintended changes in output. Add tests for the entire build pipeline from Markdown file to generated HTML.",
            "status": "done",
            "testStrategy": "Run the test suite automatically as part of CI/CD. Compare snapshot tests against previous versions to detect regressions. Ensure test coverage for all edge cases and error conditions."
          },
          {
            "id": 12,
            "title": "Write Documentation and Authoring Guide",
            "description": "Create documentation for the Markdown processing system and an authoring guide for content creators.",
            "dependencies": [
              "3.11"
            ],
            "details": "Write technical documentation for the Markdown processing system, including architecture overview, API references, and integration points. Create an authoring guide for content creators that explains required fields, naming conventions, Markdown features supported, and how to preview content. Include examples of valid frontmatter and common Markdown patterns used in projects. Document the build and deployment process for content updates.",
            "status": "done",
            "testStrategy": "Review documentation with potential users to ensure clarity. Verify examples are accurate and up-to-date. Test the authoring workflow by following the guide to create new content."
          }
        ]
      },
      {
        "id": 4,
        "title": "Design and Implement Homepage Hero Section",
        "description": "Create the hero section for the homepage that highlights Sofia's specialization in Python and AWS, with a professional profile image.",
        "details": "1. Design a visually appealing hero section with:\n   - Professional headline emphasizing Python and AWS expertise\n   - Professional profile image\n   - Brief introduction text\n   - Primary CTA button\n2. Implement responsive layout for the hero section\n3. Add subtle text animations as specified in the design considerations\n4. Optimize the profile image for web display\n5. Ensure the section is visually prominent and captures attention\n6. Implement proper heading hierarchy for SEO\n7. Create both English and Spanish versions of the content",
        "testStrategy": "Test the hero section across different screen sizes to ensure responsive behavior. Verify that text animations work correctly and don't affect usability. Check image loading performance and ensure proper alt text for accessibility. Test with both language settings to verify content switching works correctly.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold Hero Section Markup",
            "description": "Create the basic HTML structure for the hero section in the homepage template using Nunjucks templating.",
            "dependencies": [],
            "details": "Add the hero section markup to src/pages/index.njk, extending from base.njk. Include the following elements: a container div with appropriate Tailwind classes, heading (h1) for the professional title, subheading paragraph for the brief introduction, a placeholder for the profile image, and a primary CTA button. Use semantic HTML elements and ensure proper nesting structure. Add data attributes for future animation targets.",
            "status": "done",
            "testStrategy": "Verify the markup renders correctly in the browser without styling. Check that the HTML structure is valid and follows semantic principles. Ensure the template extends properly from base.njk."
          },
          {
            "id": 2,
            "title": "Implement Responsive Hero Layout with Tailwind",
            "description": "Style the hero section using Tailwind CSS to create a responsive layout that works well on all device sizes.",
            "dependencies": [
              "4.1"
            ],
            "details": "Apply Tailwind classes to create a mobile-first responsive layout: stack elements vertically on mobile, switch to side-by-side layout on lg+ screens. Use flex or grid for layout. Apply appropriate spacing, padding, and max-width constraints. Implement a container with mx-auto for centering. Style the CTA button with appropriate colors, padding, and hover states. Ensure the hero section has sufficient visual prominence through background styling, padding, and possibly a subtle gradient or accent color.",
            "status": "done",
            "testStrategy": "Test the responsive behavior across multiple screen sizes (mobile, tablet, desktop). Verify layout shifts appropriately at breakpoints. Check that spacing and sizing are visually balanced. Ensure the CTA button is properly styled and has appropriate hover states."
          },
          {
            "id": 3,
            "title": "Add and Optimize Profile Image",
            "description": "Add the professional profile image to the hero section with proper optimization for web performance.",
            "dependencies": [
              "4.1"
            ],
            "details": "Place the profile image file in public/assets/images/profile.jpg. Optimize the image for web (compress, proper dimensions). Create multiple sizes for responsive images if needed. In the markup, add the image with proper alt text, explicit width/height attributes to prevent layout shift, and appropriate Tailwind classes for sizing and styling. Consider adding a subtle border or shadow effect. Do not add lazy-loading to this image since it's likely an LCP (Largest Contentful Paint) element.",
            "status": "done",
            "testStrategy": "Verify the image loads correctly and is properly sized across devices. Check that the image file size is optimized (<200KB recommended). Ensure proper alt text is present. Confirm no layout shift occurs during image load."
          },
          {
            "id": 4,
            "title": "Implement Text Animation with Accessibility Support",
            "description": "Add subtle text animations to the hero section while ensuring accessibility compliance.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Implement subtle fade-in and/or slide-in animations for the heading, subheading, and CTA using CSS transitions or animations. Add a small stagger effect between elements. Ensure animations are short (300-500ms) and don't interfere with readability. Implement prefers-reduced-motion media query support to disable animations for users who prefer reduced motion. Use data attributes from the markup as animation hooks. Ensure no layout shifts occur during animations.",
            "status": "done",
            "testStrategy": "Test animations for smoothness and timing. Verify animations work correctly across browsers. Test with prefers-reduced-motion enabled to ensure animations are properly disabled. Check that animations don't cause performance issues or layout shifts."
          },
          {
            "id": 5,
            "title": "Implement Internationalization for Hero Content",
            "description": "Create both English and Spanish versions of the hero section content and implement language switching.",
            "dependencies": [
              "4.1"
            ],
            "details": "Create a JSON data file with English and Spanish translations for all hero section text content (heading, subheading, CTA button text). Use the existing normalizeLang utility and language filters to implement content switching. Update the hero section markup to use translation keys instead of hardcoded text. Ensure the language switch mechanism works correctly for the hero section. Verify that text length differences between languages don't break the layout.",
            "status": "done",
            "testStrategy": "Test language switching between English and Spanish. Verify all text elements correctly display the translated content. Check that longer Spanish text doesn't cause layout issues. Ensure the language state is preserved when navigating between pages."
          },
          {
            "id": 6,
            "title": "Optimize Hero Section for SEO and Accessibility",
            "description": "Ensure the hero section follows SEO best practices and meets WCAG AA accessibility standards.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.5"
            ],
            "details": "Verify proper heading hierarchy with h1 for the main headline. Add appropriate ARIA attributes where needed. Ensure sufficient color contrast (minimum 4.5:1 for normal text, 3:1 for large text) according to WCAG AA standards. Check that all interactive elements are keyboard accessible with visible focus states. Add structured data (JSON-LD) for the person information if appropriate. Ensure the CTA button has descriptive text and proper focus styling.",
            "status": "done",
            "testStrategy": "Use accessibility tools (like axe or Lighthouse) to verify WCAG AA compliance. Check keyboard navigation through the hero section. Verify color contrast meets requirements. Test with screen readers to ensure content is properly announced."
          },
          {
            "id": 7,
            "title": "Create Build Verification and Documentation",
            "description": "Implement verification checks for the hero section and update documentation.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4",
              "4.5",
              "4.6"
            ],
            "details": "Create a simple smoke test that verifies the hero section renders correctly in the built output (_site directory). Add comments in the code explaining the structure and animation approach. Update any project documentation to include information about the hero section implementation. Document the translation keys used for i18n. Create a simple checklist for content updates to the hero section. Verify that the Eleventy build process completes successfully with the new hero section.",
            "status": "done",
            "testStrategy": "Run the Eleventy build and verify the hero section appears correctly in the output HTML. Check that all assets are properly referenced and load correctly. Verify documentation is clear and helpful for future developers or content editors."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Featured Work Section",
        "description": "Create the 'Featured Work' section on the homepage that displays the most important projects in a card-based layout.",
        "details": "1. Design project cards that include:\n   - Project thumbnail image\n   - Project title\n   - Brief description\n   - Technologies used (tags)\n   - Visual hover effect (FR9)\n2. Implement a responsive grid layout that shows:\n   - 3 columns on desktop\n   - 2 columns on tablet\n   - 1 column on mobile\n3. Create a system to mark certain projects as 'featured' in the frontmatter\n4. Implement lazy loading for project images (FR19)\n5. Add smooth transitions for hover effects\n6. Ensure proper linking to individual project pages",
        "testStrategy": "Test the grid layout at various screen sizes to verify the correct number of columns. Verify that hover effects work properly and are accessible. Test image lazy loading by simulating slow network conditions. Check that all links to project pages work correctly. Verify the section renders correctly with different numbers of featured projects.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Eleventy Collection for Featured Projects",
            "description": "Set up an Eleventy collection that filters projects with 'featured: true' in their frontmatter to be displayed in the Featured Work section.",
            "dependencies": [],
            "details": "Create a custom Eleventy collection named 'featured_projects' in the .eleventy.js file that filters projects where data.featured === true. Include language filtering based on the current page locale. Sort the collection by date (newest first) or by a custom 'order' field if present in the frontmatter. Limit to a maximum of 6 featured projects.",
            "status": "done",
            "testStrategy": "Verify the collection returns only projects with featured: true. Test with multiple languages to ensure proper filtering. Check sorting order is correct."
          },
          {
            "id": 2,
            "title": "Design Project Card Component",
            "description": "Create a reusable project card component that displays project information in an attractive and accessible format.",
            "dependencies": [
              "5.1"
            ],
            "details": "Create a partial/include for project cards with the following elements: hero image (with width/height attributes, loading='lazy', decoding='async'), project title as a link to the project page, short description/excerpt (limited to ~120 characters), up to 5 technology tags displayed as chips, and proper alt text from 'alt' or 'title' field. Add hover effects with smooth transitions that slightly elevate the card and change background color. Ensure the entire card is clickable but maintains proper accessibility.",
            "status": "done",
            "testStrategy": "Test keyboard navigation and focus states. Verify hover effects work across browsers. Check that truncation of long descriptions works properly. Ensure image aspect ratios are maintained."
          },
          {
            "id": 3,
            "title": "Implement Responsive Grid Layout",
            "description": "Create a responsive grid layout for the Featured Work section that adapts to different screen sizes.",
            "dependencies": [
              "5.2"
            ],
            "details": "Using Tailwind CSS, implement a responsive grid container that displays: 1 column on mobile (xs), 2 columns on tablet (md), and 3 columns on desktop (lg). Add appropriate gap spacing between cards. Ensure the grid maintains proper alignment and spacing at all breakpoints. Use CSS Grid or Flexbox through Tailwind utilities. Add proper container padding that adjusts at different breakpoints.",
            "status": "done",
            "testStrategy": "Test at various viewport sizes to verify correct number of columns. Check that spacing and alignment remain consistent across breakpoints. Verify no horizontal overflow occurs on mobile devices."
          },
          {
            "id": 4,
            "title": "Create Featured Work Section Structure",
            "description": "Build the overall structure for the Featured Work section including heading, introduction, and navigation elements.",
            "dependencies": [
              "5.3"
            ],
            "details": "Create the section with an id='projects' for direct linking. Add a visually prominent heading ('Featured Work' or equivalent in the current language). Include an optional short introductory paragraph. Add a 'View all projects' link at the bottom of the section that points to a projects listing page. Ensure proper semantic HTML structure with appropriate heading levels. Add section padding and background styling consistent with the site design.",
            "status": "done",
            "testStrategy": "Verify the anchor ID works for direct navigation. Check that heading hierarchy is correct. Test the 'View all projects' link functionality. Ensure responsive behavior of the section container."
          },
          {
            "id": 5,
            "title": "Implement Image Optimization and Lazy Loading",
            "description": "Set up image optimization and lazy loading for project thumbnails to improve performance.",
            "dependencies": [
              "5.2"
            ],
            "details": "Implement responsive images with srcset and sizes attributes for project thumbnails. Set up a build process to generate optimized image versions at different widths (e.g., 300w, 600w, 900w). Add loading='lazy' attribute to all images. Implement a lightweight placeholder or blur-up technique for images. Add decoding='async' attribute. Ensure images have explicit width and height attributes to prevent layout shifts.",
            "status": "done",
            "testStrategy": "Test image loading performance with throttled network conditions. Verify lazy loading works correctly for below-the-fold images. Check that no layout shifts occur as images load. Validate image optimization with Lighthouse."
          },
          {
            "id": 6,
            "title": "Enhance Accessibility of Featured Work Section",
            "description": "Ensure the Featured Work section meets accessibility standards and provides a good experience for all users.",
            "dependencies": [
              "5.4"
            ],
            "details": "Add appropriate ARIA attributes where needed (e.g., aria-label for links that need additional context). Ensure sufficient color contrast for all text elements including technology tags. Implement visible focus states for interactive elements. Make cards fully keyboard navigable. Add screen reader-friendly descriptions where needed. Ensure hover effects don't rely solely on color changes. Test with keyboard navigation to ensure all elements are accessible.",
            "status": "done",
            "testStrategy": "Test with keyboard navigation to verify all interactive elements are accessible. Use accessibility tools (like axe or Lighthouse) to check for issues. Verify color contrast meets WCAG AA standards. Test with a screen reader to ensure proper information hierarchy."
          },
          {
            "id": 7,
            "title": "Add Documentation and Testing for Featured Projects",
            "description": "Create documentation for content authors and implement tests to verify the Featured Work section functions correctly.",
            "dependencies": [
              "5.1",
              "5.4",
              "5.5",
              "5.6"
            ],
            "details": "Add documentation in the project README explaining how to mark projects as featured using 'featured: true' in frontmatter. Document image requirements for optimal display in project cards. Create build-time tests that verify the section renders and contains at least one featured card. Add tests to verify external links have proper attributes (target, rel). Create snapshot tests for the section's HTML structure. Document the expected behavior of the responsive layout.",
            "status": "done",
            "testStrategy": "Run automated tests during the build process to verify section rendering. Check that documentation is clear and comprehensive. Verify that example frontmatter is provided for content authors. Test that build fails appropriately if critical elements are missing."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Certifications Section",
        "description": "Create the 'Certifications' section on the homepage that displays AWS certification badges.",
        "details": "1. Design a visually appealing certifications section\n2. Obtain official AWS certification badge images\n3. Implement a responsive layout for displaying certification badges\n4. Add metadata for each certification including:\n   - Certification name\n   - Date obtained\n   - Verification link (if applicable)\n5. Optimize badge images for web display\n6. Implement hover effects for additional information\n7. Create both English and Spanish versions of certification descriptions",
        "testStrategy": "Verify that certification badges display correctly at different screen sizes. Test hover effects to ensure additional information is accessible. Check image loading performance. Verify that verification links work correctly if implemented. Test with both language settings to ensure proper content switching.",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Certifications Data Model",
            "description": "Design and implement the data structure for storing certification information in a JSON file.",
            "dependencies": [],
            "details": "Create src/data/certifications.json with a schema that includes id, name, issuer, issueDate, credentialUrl, badgeImage, alt, and optional expiresDate fields. Include at least one real AWS certification example. Ensure the structure supports both English and Spanish localization by referencing keys in i18n.json for text content.",
            "status": "done",
            "testStrategy": "Validate JSON structure with a schema validator. Ensure required fields are present and formatted correctly."
          },
          {
            "id": 2,
            "title": "Add Certification Badge Assets",
            "description": "Obtain and optimize AWS certification badge images for web display.",
            "dependencies": [],
            "details": "Source official AWS certification badge images. Create public/assets/certs/ directory. Optimize badges as SVG (preferred) or PNG with appropriate dimensions. Ensure each image has explicit width and height attributes. Name files consistently (e.g., aws-solutions-architect.svg).",
            "status": "done",
            "testStrategy": "Verify image optimization with tools like ImageOptim. Check file sizes are under 30KB each. Confirm width and height attributes are set."
          },
          {
            "id": 3,
            "title": "Implement Certifications Section HTML Structure",
            "description": "Create the base HTML structure for the certifications section on the homepage.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Add a section with id=\"certifications\" to the homepage template. Include a localized H2 heading. Create a responsive grid container for certification cards. Implement the card template in Nunjucks that displays the badge image, certification name, issuer, issue date, and credential verification link.",
            "status": "done",
            "testStrategy": "Validate HTML structure. Ensure proper semantic markup and heading hierarchy."
          },
          {
            "id": 4,
            "title": "Style Certifications Section with Tailwind",
            "description": "Apply Tailwind CSS styling to the certifications section for responsive layout and visual appeal.",
            "dependencies": [
              "6.3"
            ],
            "details": "Implement a responsive grid layout (2 columns on small screens, 3 on medium, 4 on large). Add appropriate padding, margins, and gaps. Style certification cards with consistent spacing. Create hover/focus effects that are reduced-motion friendly. Ensure keyboard focus is visibly indicated.",
            "status": "done",
            "testStrategy": "Test responsive behavior across different viewport sizes. Verify hover/focus states work correctly. Check for any layout issues or overflow."
          },
          {
            "id": 5,
            "title": "Implement i18n for Certification Content",
            "description": "Add localization support for all certification text content.",
            "dependencies": [
              "6.1",
              "6.3"
            ],
            "details": "Update src/data/i18n.json with keys for certifications.heading, certifications.issuer, certifications.viewCredential, certifications.issuedOn, etc. Provide both English and Spanish translations. Connect these keys to the Nunjucks templates. Format dates according to locale preferences.",
            "status": "done",
            "testStrategy": "Switch between languages to verify all text content changes appropriately. Check date formatting is locale-appropriate."
          },
          {
            "id": 6,
            "title": "Add JSON-LD Structured Data",
            "description": "Implement structured data for certifications to improve SEO.",
            "dependencies": [
              "6.1",
              "6.3"
            ],
            "details": "Create a script[type=\"application/ld+json\"] element in the certifications section or page head. Generate JSON-LD for each certification using the EducationalOccupationalCredential schema. Include name, issuer (as Organization), datePublished, and url properties. Dynamically generate this from the certifications data.",
            "status": "done",
            "testStrategy": "Validate JSON-LD using Google's Structured Data Testing Tool or Schema.org Validator. Ensure all required properties are present and correctly formatted."
          },
          {
            "id": 7,
            "title": "Implement Accessibility Enhancements",
            "description": "Ensure the certifications section meets accessibility standards.",
            "dependencies": [
              "6.3",
              "6.4"
            ],
            "details": "Add appropriate aria-labels to links where text is not fully descriptive (e.g., aria-label=\"View credential: {name}\"). Ensure all images have descriptive alt text. Verify proper keyboard navigation through the certification cards. Add appropriate external link indicators with target=\"_blank\" rel=\"noopener noreferrer\" for credential URLs.",
            "status": "done",
            "testStrategy": "Test keyboard navigation. Run accessibility checks with tools like axe or Lighthouse. Verify screen reader compatibility."
          },
          {
            "id": 8,
            "title": "Add Documentation and Tests",
            "description": "Create documentation for the certifications feature and implement tests.",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4",
              "6.5",
              "6.6",
              "6.7"
            ],
            "details": "Update README.md or create a specific doc explaining how to add new certifications, required fields, asset placement, and i18n considerations. Extend or create build-time tests in scripts/test-build.js to verify: section#certifications exists, at least one card renders, external links include rel attributes, images have width/height attributes, and JSON-LD is present.",
            "status": "done",
            "testStrategy": "Run the build-time tests to ensure all components render correctly. Manually verify documentation accuracy by adding a test certification following the instructions."
          }
        ]
      },
      {
        "id": 7,
        "title": "Develop Individual Project Page Template",
        "description": "Create the template for individual project pages that will display the full content of each project with proper formatting.",
        "details": "1. Design a project page template with:\n   - Hero banner with project image (FR13)\n   - Project metadata section (title, dates, employer, etc.)\n   - Main content area with proper typography\n   - 'Technologies Used' section generated from tags (FR15)\n   - Navigation to other projects\n2. Implement the Tailwind 'prose' class for content formatting\n3. Create a responsive layout that prioritizes readability\n4. Add proper semantic HTML structure for SEO\n5. Implement metadata extraction from frontmatter\n6. Set up language-specific content display based on the language setting",
        "testStrategy": "Test the project page with various types of Markdown content to ensure proper rendering. Verify that all metadata from frontmatter is correctly displayed. Test responsiveness across different screen sizes. Check that the 'Technologies Used' section correctly displays all tags. Test with both English and Spanish content to verify language switching works correctly.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic Project Template Structure with Semantic HTML",
            "description": "Set up the initial Nunjucks template file with proper semantic HTML structure for the project page layout.",
            "dependencies": [],
            "details": "Create src/layouts/project.njk with semantic HTML structure including <header>, <article>, and <section> tags. Implement the basic page structure with proper heading hierarchy. Include placeholders for all required sections: hero banner, metadata section, main content area, technologies section, and project navigation.",
            "status": "done",
            "testStrategy": "Verify the template compiles without errors using 'npm run build'. Check HTML validity and semantic structure using the W3C validator."
          },
          {
            "id": 2,
            "title": "Implement Hero Banner with Project Image",
            "description": "Create the hero banner section that displays the project's featured image with proper performance attributes and fallback handling.",
            "dependencies": [
              "7.1"
            ],
            "details": "In the hero banner section, implement an image element that sources from project.heroImage. Add performance attributes (loading=\"lazy\", decoding=\"async\"). Implement proper alt text fallback using alt || title. Style the hero banner with appropriate sizing and responsive behavior using Tailwind classes.",
            "status": "done",
            "testStrategy": "Test with projects that have and don't have hero images to verify fallback behavior. Verify image performance attributes are correctly applied in the output HTML."
          },
          {
            "id": 3,
            "title": "Develop Project Metadata Section",
            "description": "Create the metadata section displaying project title, date range, employer, and other relevant information from frontmatter.",
            "dependencies": [
              "7.1"
            ],
            "details": "Extract and display project metadata from frontmatter including title, employer, and date range. Use the dateRange(startDate, endDate, language) filter for formatting dates according to the current language. Style the metadata section with appropriate typography and spacing using Tailwind classes.",
            "status": "done",
            "testStrategy": "Test with projects having different metadata combinations. Verify date formatting works correctly in both languages. Check that all metadata fields are properly extracted and displayed."
          },
          {
            "id": 4,
            "title": "Implement Main Content Area with Tailwind Prose",
            "description": "Set up the main content area that renders the Markdown content with proper typography and formatting.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement the main content area using {{ content | safe }} to render the Markdown content. Apply Tailwind's prose classes for proper typography and content formatting. Ensure the content area is responsive and maintains readability across different screen sizes.",
            "status": "done",
            "testStrategy": "Test with various Markdown content types (headings, lists, code blocks, images) to ensure proper rendering. Verify responsive behavior on different screen sizes."
          },
          {
            "id": 5,
            "title": "Create Technologies Used Section from Tags",
            "description": "Implement the section that displays the technologies used in the project based on frontmatter tags.",
            "dependencies": [
              "7.1"
            ],
            "details": "Create a 'Technologies Used' section that iterates through project tags and displays them. Filter out the 'project' tag which is used for collection purposes. Style the tags consistently with the design system. Implement proper heading and semantic structure for this section.",
            "status": "done",
            "testStrategy": "Test with projects having different numbers of tags. Verify the 'project' tag is correctly excluded. Check the responsive layout of tags on different screen sizes."
          },
          {
            "id": 6,
            "title": "Implement Project Navigation",
            "description": "Create navigation links to previous and next projects with proper accessibility and internationalization.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement previous/next project navigation at the bottom of the template. Use the collections.projects.byLanguage filter to ensure navigation only includes projects in the current language. Add proper accessible labels using the t(language) filter for internationalization. Style the navigation with appropriate visual cues and spacing.",
            "status": "done",
            "testStrategy": "Test navigation between projects to ensure correct sequencing. Verify language filtering works correctly. Check accessibility of navigation elements with screen readers."
          },
          {
            "id": 7,
            "title": "Implement Language-Specific Content Display",
            "description": "Ensure all content and UI elements adapt to the selected language setting.",
            "dependencies": [
              "7.3",
              "7.5",
              "7.6"
            ],
            "details": "Implement language-specific display for all text elements using the t(language) filter. Ensure date formatting respects the current language setting. Test and verify that navigation only shows projects in the current language using the byLanguage filter.",
            "status": "done",
            "testStrategy": "Test the template with both English and Spanish content to verify correct language display. Check that date formats follow language conventions. Verify navigation only shows projects in the current language."
          },
          {
            "id": 8,
            "title": "Add Tests and Update Test Scripts",
            "description": "Update existing test scripts to verify the project template implementation and create new tests as needed.",
            "dependencies": [
              "7.2",
              "7.3",
              "7.4",
              "7.5",
              "7.6",
              "7.7"
            ],
            "details": "Update scripts/test-build.js to include tests for the project template. Add snapshot expectations for project pages. Create tests to verify all required sections are present and correctly formatted. Document which tests are satisfied by the current implementation and what needs additional verification.",
            "status": "done",
            "testStrategy": "Run the updated test scripts to verify all aspects of the project template. Check that snapshots match expected output. Manually verify visual aspects that automated tests cannot cover."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement SEO Optimization",
        "description": "Implement SEO features to optimize the site for search engines, particularly for terms related to 'Python AWS developer'.",
        "details": "1. Create a system to automatically generate meta tags for each page (FR20):\n   - Title tags\n   - Meta descriptions\n   - Open Graph tags for social sharing\n   - Twitter card tags\n2. Implement canonical URLs\n3. Create a sitemap.xml generator\n4. Implement structured data (JSON-LD) for:\n   - Person information\n   - Professional experience\n   - Skills\n5. Optimize heading hierarchy across the site\n6. Implement alt text for all images\n7. Create a robots.txt file\n8. Ensure proper semantic HTML throughout the site",
        "testStrategy": "Use tools like Google's Structured Data Testing Tool to verify JSON-LD implementation. Test meta tags generation for various page types. Validate the sitemap.xml format. Use Lighthouse to test SEO score (target >90 as per SM6). Verify that all images have appropriate alt text. Check that canonical URLs are correctly implemented.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create a centralized SEO component for Meta Tags and Canonical URLs",
            "description": "Develop a reusable Astro component (e.g., `Seo.astro`) that dynamically generates essential meta tags. This component will be integrated into the main `BaseLayout.astro` to ensure all pages have proper SEO metadata.",
            "dependencies": [],
            "details": "The `Seo.astro` component should accept props like `title`, `description`, `image`, `canonicalURL`, and `type` (e.g., 'website', 'article'). It must generate: \n- `<title>` tag (formatted as 'Page Title | Sofia Escobedo - Python & AWS Developer')\n- `<meta name=\"description\">`\n- `<link rel=\"canonical\">` to the page's absolute URL.\n- Open Graph tags (`og:title`, `og:description`, `og:image`, `og:url`, `og:type`)\n- Twitter Card tags (`twitter:card`, `twitter:title`, `twitter:description`, `twitter:image`).\nUpdate `BaseLayout.astro` to use this component, passing data from the page's frontmatter or props.",
            "status": "done",
            "testStrategy": "Inspect the `<head>` of the homepage, a project page, and other pages to verify that all meta and canonical tags are generated correctly and reflect the page's specific content. Use a browser extension like 'SEO META in 1 CLICK' to validate."
          },
          {
            "id": 2,
            "title": "Implement sitemap.xml and robots.txt",
            "description": "Configure the project to automatically generate a `sitemap.xml` file and create a `robots.txt` file to guide search engine crawlers.",
            "dependencies": [],
            "details": "1. Install and configure the official Astro sitemap integration (`@astrojs/sitemap`) in the `astro.config.mjs` file. Ensure the `site` property is correctly set to the production domain. \n2. Create a `robots.txt` file in the `public/` directory. The file should allow crawling for all user agents (`User-agent: *`, `Allow: /`) and include a line pointing to the sitemap's location (e.g., `Sitemap: https://your-domain.com/sitemap-index.xml`).",
            "status": "done",
            "testStrategy": "After building the site for production, verify that `dist/sitemap-index.xml` and its referenced sitemaps are created correctly. Check that `dist/robots.txt` exists and has the correct content. Submit the sitemap to Google Search Console for validation."
          },
          {
            "id": 3,
            "title": "Implement JSON-LD Structured Data for Person and Profile",
            "description": "Create and inject JSON-LD structured data into the homepage to provide rich context about Sofia Escobedo to search engines.",
            "dependencies": [
              "8.1"
            ],
            "details": "Create a new component, `JsonLD.astro`, to generate a `<script type=\"application/ld+json\">` tag. On the homepage (`src/pages/index.astro`), use this component to output a `Person` schema. This schema should include `name`, `url` (portfolio link), `sameAs` (links to LinkedIn, GitHub), `jobTitle` ('Python & AWS Developer'), and `alumniOf`. You can also nest or add a `WebSite` schema. The data should be stored in a central config file (e.g., `src/config.ts`) for easy management.",
            "status": "done",
            "testStrategy": "Deploy the changes and use Google's Rich Results Test to validate the homepage URL. Ensure there are no errors and that the `Person` structured data is correctly parsed."
          },
          {
            "id": 4,
            "title": "Audit and Implement Alt Text for All Images",
            "description": "Conduct a site-wide audit to ensure every `<img>` tag and Astro `<Image>` component has meaningful and descriptive `alt` text for accessibility and SEO.",
            "dependencies": [],
            "details": "Review all `.astro` files in `src/components` and `src/pages`. Pay special attention to components that render images, such as `FeaturedWork.astro` (project thumbnails) and `Certifications.astro` (certification badges). For dynamic images from Markdown frontmatter, ensure the `alt` text is either included in the frontmatter or derived from the project title. For static images like logos or UI elements, add descriptive static `alt` attributes.",
            "status": "done",
            "testStrategy": "Use a browser's developer tools to inspect all images on the live site. Run a Lighthouse audit in Chrome DevTools and check that the SEO score is not penalized for missing alt text. The accessibility score should also improve."
          },
          {
            "id": 5,
            "title": "Optimize Heading Hierarchy and Semantic HTML Structure",
            "description": "Audit and refactor the site's HTML to ensure a logical heading hierarchy (H1-H6) and the correct use of semantic elements like `<main>`, `<section>`, and `<article>`.",
            "dependencies": [],
            "details": "1. **Heading Audit:** Review `BaseLayout.astro`, `index.astro`, and the project detail page template (`src/pages/work/[...slug].astro`). Ensure there is strictly one `<h1>` per page (typically the page title). Subsequent headings should follow a logical order (`<h2>`, `<h3>`, etc.) without skipping levels. \n2. **Semantic HTML:** Verify that the main content of each page is wrapped in a `<main>` tag. Use `<section>` for distinct sections on the homepage (e.g., 'Featured Work', 'About Me'). Use the `<article>` tag for self-contained content, such as individual project entries on the work detail page.",
            "status": "done",
            "testStrategy": "Use a browser extension like 'Web Developer' to outline heading structures on key pages to verify logical order. Manually inspect the DOM to confirm the correct usage of `<main>`, `<section>`, and `<article>` tags. Re-run a Lighthouse audit to check for improvements in SEO and Accessibility scores."
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Language Switching Functionality",
        "description": "Implement a complete language switching system that allows users to toggle between English and Spanish content throughout the site.",
        "details": "1. Design a language switcher UI component\n2. Implement a language state management system\n3. Create a translation system that supports:\n   - UI elements (navigation, buttons, etc.)\n   - Static content on the homepage\n   - Dynamic content from Markdown files\n4. Store language preference in localStorage\n5. Update URL with language parameter\n6. Implement proper lang attribute on HTML elements\n7. Ensure all date formats adapt to the selected language\n8. Add language metadata to the page head",
        "testStrategy": "Test language switching on all pages to verify content changes correctly. Verify that language preference is saved between sessions. Test URL-based language switching. Check that dates and other formatted content adapt to the selected language. Verify that the lang attribute is correctly updated in the HTML. Test with screen readers to ensure accessibility.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create language state management module",
            "description": "Implement a core language state management module that handles language selection, persistence, and retrieval.",
            "dependencies": [],
            "details": "Create a languageManager.js module with functions to: 1) Get current language (defaulting to browser language or 'en'), 2) Set language preference, 3) Save language to localStorage, 4) Read language from localStorage, 5) Parse language from URL parameters. Include a default language configuration object with supported languages (en, es). Implement proper error handling and input validation for URL parameters.",
            "status": "done",
            "testStrategy": "Unit test each function in isolation. Test localStorage persistence across page reloads. Test URL parameter parsing with valid and invalid inputs. Test browser language detection fallback."
          },
          {
            "id": 2,
            "title": "Design and implement language switcher UI component",
            "description": "Create an accessible language switcher UI component for the site header that allows users to toggle between English and Spanish.",
            "dependencies": [
              "10.1"
            ],
            "details": "Create a language-switcher.js component that renders a toggle button with language options. Style according to site design system. Implement with proper ARIA attributes (aria-label, aria-expanded, etc.). Add keyboard navigation support. Ensure the component displays the current active language. Add event listeners to trigger language change using the language state manager. Prevent page flicker on language change.",
            "status": "done",
            "testStrategy": "Test keyboard accessibility (tab navigation, Enter/Space activation). Test ARIA attributes are correctly set. Test visual states (hover, focus, active). Test that language change events are properly triggered."
          },
          {
            "id": 3,
            "title": "Implement translation system for UI elements",
            "description": "Create a translation system for UI elements like navigation, buttons, and other static interface components.",
            "dependencies": [
              "10.1"
            ],
            "details": "Create a translations.js file with a structured object containing UI string translations for both languages. Implement a translate() function that accepts a key and returns the appropriate string based on current language. Add a mechanism to update all UI elements when language changes. Create data attributes (e.g., data-i18n-key) for HTML elements that need translation. Implement observer pattern to notify UI when language changes.",
            "status": "done",
            "testStrategy": "Test translation retrieval for all UI strings in both languages. Test fallback behavior for missing translations. Test dynamic UI updates when language changes. Verify all navigation items and buttons display correctly in both languages."
          },
          {
            "id": 4,
            "title": "Implement static content translation for homepage",
            "description": "Create a system to translate static content on the homepage between English and Spanish.",
            "dependencies": [
              "10.1",
              "10.3"
            ],
            "details": "Extend the translation system to handle longer content blocks. Create content JSON files for homepage sections in both languages. Implement a content loader that fetches the appropriate language content. Add a mechanism to swap content when language changes without page reload. Ensure content maintains proper formatting and layout when switched.",
            "status": "done",
            "testStrategy": "Test content loading for both languages. Verify all homepage sections display correctly after language switch. Test edge cases like partial translations. Check that formatting and layout remain consistent across languages."
          },
          {
            "id": 5,
            "title": "Implement Markdown content language handling",
            "description": "Create a system to handle multilingual content in Markdown files with appropriate fallback mechanisms.",
            "dependencies": [
              "10.1"
            ],
            "details": "Modify the Markdown processing pipeline to support language-specific content. Update frontmatter schema to include language identifier. Implement a content selection algorithm that: 1) Tries to load content in the requested language, 2) Falls back to default language if translation unavailable, 3) Indicates to the user when content is displayed in fallback language. Create a directory structure that supports multilingual content organization.",
            "status": "done",
            "testStrategy": "Test content loading with both languages available. Test fallback behavior when translation is missing. Verify frontmatter parsing works correctly with language metadata. Test edge cases like partial translations or malformed language identifiers."
          },
          {
            "id": 6,
            "title": "Implement URL-based language switching",
            "description": "Add support for language selection via URL parameters and update URLs when language is changed.",
            "dependencies": [
              "10.1",
              "10.2"
            ],
            "details": "Extend languageManager.js to parse the 'lang' URL parameter. Implement URL updating when language changes (using History API). Add language parameter to all internal links. Ensure bookmarking works with language preference. Sanitize URL parameters to prevent XSS. Handle edge cases like invalid language codes in URL. Maintain other URL parameters when updating language.",
            "status": "done",
            "testStrategy": "Test URL parameter parsing with various inputs. Test URL updates when language changes. Verify bookmarked URLs load with correct language. Test security aspects with malformed inputs. Test that other URL parameters are preserved during language change."
          },
          {
            "id": 7,
            "title": "Implement HTML language attributes and metadata",
            "description": "Update HTML lang attribute and add appropriate language metadata to the page head for SEO and accessibility.",
            "dependencies": [
              "10.1"
            ],
            "details": "Create a function to update the HTML lang attribute when language changes. Implement hreflang link tags in the head for language alternatives. Add language-specific metadata for SEO. Update document title with localized version when language changes. Ensure all language codes follow ISO standards. Implement proper RTL support if needed in the future.",
            "status": "done",
            "testStrategy": "Verify HTML lang attribute updates correctly. Test hreflang tags are properly generated. Check that metadata is correctly updated for SEO. Test with screen readers to verify accessibility improvements."
          },
          {
            "id": 8,
            "title": "Implement localized date and number formatting",
            "description": "Create a system to format dates, numbers, and other locale-specific content according to the selected language.",
            "dependencies": [
              "10.1"
            ],
            "details": "Create a formatting.js utility with functions for date and number formatting based on current language. Use Intl API for localization. Implement functions for common formats (short date, long date, currency, etc.). Add data attributes to mark elements needing localized formatting. Update formatted elements when language changes. Handle timezone considerations.",
            "status": "done",
            "testStrategy": "Test date formatting in both languages. Verify number formatting follows locale conventions. Test currency formatting if applicable. Test dynamic updates of formatted content when language changes."
          },
          {
            "id": 9,
            "title": "Implement language preference persistence",
            "description": "Ensure language preference is saved between sessions and properly restored on site revisit.",
            "dependencies": [
              "10.1",
              "10.6"
            ],
            "details": "Enhance languageManager.js to robustly save language preference to localStorage. Implement proper initialization sequence: 1) Check URL parameters first, 2) Fall back to localStorage if no URL parameter, 3) Use browser language detection as final fallback, 4) Default to English if all else fails. Add expiration to stored preferences if needed. Handle localStorage unavailability gracefully.",
            "status": "done",
            "testStrategy": "Test persistence across page reloads and browser restarts. Test the full initialization sequence with different scenarios. Test behavior when localStorage is unavailable or disabled. Verify priority order of different language sources (URL > localStorage > browser language > default)."
          },
          {
            "id": 10,
            "title": "Create comprehensive tests for language system",
            "description": "Implement end-to-end and integration tests for the complete language switching functionality.",
            "dependencies": [
              "10.1",
              "10.2",
              "10.3",
              "10.4",
              "10.5",
              "10.6",
              "10.7",
              "10.8",
              "10.9"
            ],
            "details": "Create automated tests that verify the complete language switching flow. Test integration between all components. Implement visual regression tests to ensure layout doesn't break with different language content lengths. Create test cases for all edge cases and error scenarios. Test performance impact of language switching. Verify accessibility compliance in both languages. Document test coverage and results.",
            "status": "done",
            "testStrategy": "Run end-to-end tests simulating real user language switching. Test all pages in both languages. Verify visual consistency across languages. Test with screen readers and keyboard navigation. Measure and document performance metrics for language switching operations."
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement AWS CloudWatch RUM Integration",
        "description": "Integrate AWS CloudWatch Real User Monitoring (RUM) to track performance metrics and user behavior.",
        "details": "1. Set up an AWS CloudWatch RUM app monitor\n2. Configure the RUM web client:\n   - Install the required JavaScript\n   - Configure session sampling\n   - Set up custom events for important user interactions\n3. Implement tracking for key metrics:\n   - Page load times\n   - CTA button clicks\n   - Time spent on project pages\n   - Language switching\n4. Set up custom dashboards in CloudWatch\n5. Configure alerts for performance degradation\n6. Implement privacy-conscious data collection\n7. Add a privacy notice regarding analytics",
        "testStrategy": "Verify that the RUM client is correctly sending data to CloudWatch. Test custom event tracking by performing the tracked actions. Check that dashboards display the expected metrics. Verify that no personally identifiable information is being collected without consent. Test with various browsers to ensure compatibility.",
        "priority": "low",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure the RUM Web Client in Base Layout",
            "description": "Integrate the core AWS RUM script into the main layout of the application. This involves setting up environment variables for the configuration and injecting the script into the <head> of the `BaseLayout.astro` file.",
            "dependencies": [],
            "details": "1. Create a `.env` file in the project root if it doesn't exist. Add `PUBLIC_RUM_APPLICATION_ID` and `PUBLIC_RUM_GUEST_ROLE_ARN` and `PUBLIC_RUM_IDENTITY_POOL_ID` and `PUBLIC_RUM_REGION`.\n2. Edit `src/layouts/BaseLayout.astro`.\n3. In the `<head>` section, add a `<script is:inline>` tag.\n4. Inside the script, paste the AWS RUM web client initialization code.\n5. Replace the hardcoded configuration values in the script with the environment variables using `import.meta.env.PUBLIC_...`.\n6. Ensure the script is one of the first elements in the `<head>` to accurately capture page load performance.",
            "status": "done",
            "testStrategy": "Load the website and use the browser's developer tools to verify that the RUM script is loaded. Check the network tab for requests to `dataplane.rum.us-east-1.amazonaws.com` (or the configured region). Verify in the AWS CloudWatch RUM console that session data is starting to appear."
          },
          {
            "id": 2,
            "title": "Create a Centralized RUM Helper Module",
            "description": "To promote clean code and reusability, create a TypeScript module that encapsulates the logic for sending custom events to AWS RUM. This module will be used by other components to track specific user interactions.",
            "dependencies": [
              "12.1"
            ],
            "details": "1. Create a new file at `src/scripts/rum.ts`.\n2. In this file, define and export a function, e.g., `recordRumEvent(type: string, details: object)`. \n3. This function should check if the `awsRum` object is available on the `window` object before attempting to call `awsRum.recordEvent(type, details)`.\n4. This prevents errors if the RUM script fails to load or is blocked by an ad-blocker.",
            "status": "done",
            "testStrategy": "Call the `recordRumEvent` function from the browser console on a page where the RUM client is active. Verify in the CloudWatch RUM console that the custom event appears under the 'Custom events' tab."
          },
          {
            "id": 3,
            "title": "Implement Event Tracking for CTA Clicks and Language Switching",
            "description": "Track key user interactions by attaching custom RUM events to Call-to-Action (CTA) buttons and the language switcher, as specified in the task requirements.",
            "dependencies": [
              "12.2"
            ],
            "details": "1. Import the `recordRumEvent` function into relevant components.\n2. In `src/components/Header.astro`, add an `onclick` attribute to the 'Agendar llamada' CTA button. The handler should call `recordRumEvent('cta_click', { button: 'schedule_call' })`.\n3. In `src/components/LanguageSwitcher.astro`, add an `onclick` attribute to the language switch link. The handler should call `recordRumEvent('language_switch', { to_lang: targetLangCode })`.\n4. Add `data-rum-id` attributes to these elements for easier identification in RUM session traces.",
            "status": "done",
            "testStrategy": "Click the main CTA button and the language switcher. Go to the AWS CloudWatch RUM console, find your session, and verify that the `cta_click` and `language_switch` custom events were recorded with the correct details."
          },
          {
            "id": 4,
            "title": "Implement Event Tracking for Project Page Views",
            "description": "To measure time spent on project pages, dispatch a custom event whenever a user navigates to a specific project page. This will allow for more granular analysis of user engagement with portfolio items.",
            "dependencies": [
              "12.2"
            ],
            "details": "1. Edit the project detail page template, likely located at `src/pages/proyectos/[slug].astro`.\n2. Add a `<script is:inline>` tag to the page.\n3. Inside the script, import `recordRumEvent` from `src/scripts/rum.ts`.\n4. Call the function to record a page view event, e.g., `recordRumEvent('project_page_view', { project_slug: Astro.params.slug })`.\n5. This will fire an event each time a project page is loaded, which can be used in CloudWatch to analyze user flow and time on page.",
            "status": "done",
            "testStrategy": "Navigate to several different project detail pages. In the CloudWatch RUM console, check for `project_page_view` events and verify that the `project_slug` detail is correctly populated for each page visited."
          },
          {
            "id": 5,
            "title": "Implement Privacy Consent for RUM Initialization",
            "description": "To ensure privacy-conscious data collection, the RUM script should only be initialized after the user has given their consent. This involves creating a simple consent UI and conditionally loading the RUM script.",
            "dependencies": [
              "12.1"
            ],
            "details": "1. Create a new Astro component, e.g., `src/components/PrivacyBanner.astro`.\n2. The banner should have an 'Accept' button that, when clicked, sets a flag in `localStorage` (e.g., `localStorage.setItem('consent_given', 'true')`) and hides the banner.\n3. The banner should only be displayed if the `consent_given` flag is not set.\n4. In `src/layouts/BaseLayout.astro`, wrap the RUM initialization script from subtask 12.1 in a client-side script that checks for `localStorage.getItem('consent_given') === 'true'` before executing the RUM initialization code.\n5. Add the `<PrivacyBanner />` component to `BaseLayout.astro`.",
            "status": "done",
            "testStrategy": "On first visit in a new incognito window, verify the privacy banner is shown and no RUM traffic is sent. Click 'Accept', verify the banner disappears and RUM traffic begins. Reload the page and verify the banner does not reappear and RUM traffic is sent immediately."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-12T17:38:29.434Z",
      "updated": "2025-09-13T23:58:05.380Z",
      "description": "Tasks for default context",
      "renamed": {
        "from": "default",
        "date": "2025-09-13T23:17:13.374Z"
      }
    }
  },
  "astro-migration": {
    "tasks": [
      {
        "id": 6,
        "title": "Initialize Astro Project and Core Configuration",
        "description": "Set up a new Astro project, install all necessary dependencies, and configure the basic project settings for TypeScript, Tailwind CSS, and sitemap generation. This task establishes the foundation for the migration.",
        "details": "Create a new Astro project. Install `@astrojs/tailwind`, `@astrojs/typescript`, and `@astrojs/sitemap`. Create and configure `astro.config.mjs`, including setting up the Tailwind integration and i18n domains for 'en' and 'es'. Configure `tsconfig.json` for Astro's requirements. Update `package.json` with new `dev`, `build`, and `preview` scripts, and remove Eleventy-related dependencies like `@11ty/eleventy` and `nunjucks`.",
        "testStrategy": "Run `npm run dev` and verify that the Astro development server starts without errors. Check that a basic 'Hello World' page renders correctly. Ensure the `astro.config.mjs` and `tsconfig.json` files are correctly parsed by the Astro CLI.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Empty Astro Project",
            "description": "Create a new, empty Astro project within the existing repository structure. This will generate the foundational files like `package.json`, `astro.config.mjs`, and `tsconfig.json` without any boilerplate pages.",
            "dependencies": [],
            "details": "Run `npm create astro@latest . -- --template empty --skip-houston` in the project root. The `.` argument ensures installation in the current directory. This command will overwrite the existing `package.json` and create the necessary Astro configuration files.",
            "status": "done",
            "testStrategy": "Verify that `astro.config.mjs`, a new `package.json` with Astro dependencies, and `tsconfig.json` are created in the project root."
          },
          {
            "id": 2,
            "title": "Clean Up Old Dependencies and Install Astro Integrations",
            "description": "Remove all Eleventy-related dependencies from `package.json` and install the required Astro integrations for Tailwind CSS and sitemap generation.",
            "dependencies": [
              "6.1"
            ],
            "details": "Manually edit `package.json` to remove devDependencies like `@11ty/eleventy` and `nunjucks`. Then, run `npm install`. After cleaning up, install the new integrations by running `npm install @astrojs/tailwind @astrojs/sitemap`. Note: `@astrojs/typescript` is built-in and does not need to be installed separately.",
            "status": "done",
            "testStrategy": "Inspect `package.json` and the `node_modules` directory to confirm that Eleventy packages are gone and `@astrojs/tailwind` and `@astrojs/sitemap` are present."
          },
          {
            "id": 3,
            "title": "Update package.json Scripts for Astro CLI",
            "description": "Replace the outdated Eleventy build scripts in `package.json` with the standard commands for running, building, and previewing an Astro site.",
            "dependencies": [
              "6.1"
            ],
            "details": "Modify the `scripts` object in `package.json` to include: `\"dev\": \"astro dev\"`, `\"start\": \"astro dev\"`, `\"build\": \"astro build\"`, and `\"preview\": \"astro preview\"`. This ensures that `npm run dev` and other commands will use the Astro CLI.",
            "status": "done",
            "testStrategy": "Run `npm run dev` and confirm that the Astro development server starts up without errors, displaying a default 404 page since no pages have been created yet."
          },
          {
            "id": 4,
            "title": "Configure Astro Integrations and i18n",
            "description": "Configure the `astro.config.mjs` file to enable the Tailwind and Sitemap integrations, and set up the internationalization (i18n) routing for English ('en') and Spanish ('es').",
            "dependencies": [
              "6.2"
            ],
            "details": "In `astro.config.mjs`, import `tailwind` and `sitemap`. Add them to the `integrations` array. Set the `site` property to the production URL (e.g., 'https://www.davebitter.com'). Configure the `i18n` object with `defaultLocale: 'en'`, `locales: ['en', 'es']`, and `routing: { prefixDefaultLocale: true }`.",
            "status": "done",
            "testStrategy": "Restart the dev server. While no pages exist, check the server logs for any errors related to parsing `astro.config.mjs`. No errors indicates a successful configuration."
          },
          {
            "id": 5,
            "title": "Configure tsconfig.json and Tailwind",
            "description": "Finalize the TypeScript configuration for Astro path aliases and ensure the Tailwind CSS configuration file is set up to scan Astro components for classes.",
            "dependencies": [
              "6.1",
              "6.4"
            ],
            "details": "In `tsconfig.json`, update `compilerOptions` to add a `baseUrl` of `.` and `paths` for `'@/*': ['src/*']`. In `tailwind.config.mjs` (you may need to rename `tailwind.config.js`), ensure the `content` array includes `'./src/**/*.{astro,html,js,jsx,md,mdx,ts,tsx}'`. Create a `src/styles/global.css` file with the three Tailwind directives: `@tailwind base;`, `@tailwind components;`, `@tailwind utilities;`.",
            "status": "done",
            "testStrategy": "Create a temporary `src/pages/index.astro` file. Import `../styles/global.css`. Add an `<h1>` with a Tailwind class like `text-red-500`. Run `npm run dev` and verify the text is red, confirming both `tsconfig.json` paths (for CSS import) and Tailwind are working."
          }
        ]
      },
      {
        "id": 7,
        "title": "Migrate Nunjucks Layouts and Partials to Astro Components",
        "description": "Convert the existing Nunjucks base layout (`base.njk`) and all included partials (e.g., header, footer, project cards) into reusable Astro components (`.astro`). This includes migrating the AWS RUM script.",
        "details": "Create a main `src/layouts/Layout.astro` file that replicates the structure of `base.njk`, including the `<head>`, SEO meta tags, and the AWS CloudWatch RUM script. Use Astro's `<slot />` element to render page content. Convert all files from `src/_includes/partials/` (like `project-card.njk`, `json-ld.njk`) into corresponding `.astro` components in a `src/components/` directory. Replace Nunjucks syntax (`{{ variable }}`, `{% if %}`) with Astro/JSX equivalents (`{variable}`, `{condition && ...}`).",
        "testStrategy": "Create a temporary test page that uses the new `Layout.astro` and includes the migrated components. Verify that the layout renders correctly and that all components appear as expected with static props. Check the browser's source code to ensure the RUM script and meta tags are present.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Base Astro Layout from base.njk",
            "description": "Create a new `src/layouts/Layout.astro` file that replicates the basic HTML structure of `src/_includes/base.njk`. This includes the `<html>`, `<head>`, and `<body>` tags, and uses Astro's `<slot />` element in place of Nunjucks' `{{ content | safe }}`.",
            "dependencies": [],
            "details": "Analyze `src/_includes/base.njk`. Create `src/layouts/Layout.astro`. Define a `Props` interface for expected page-level properties like `title` and `description`. Use these props to populate the `<title>` tag and basic meta tags (charset, viewport). The body should contain a `<main>` tag wrapping the `<slot />` for now. Other partials like header/footer will be added in subsequent tasks.",
            "status": "done",
            "testStrategy": "Create a temporary `src/pages/test-layout.astro` page that uses the new `Layout.astro` and contains a simple `<h1>Hello World</h1>`. Run the dev server and verify the page title and basic HTML structure are correct."
          },
          {
            "id": 2,
            "title": "Migrate Header, Footer, and Skip-Link Partials",
            "description": "Convert `header.njk`, `footer.njk`, and `skip-link.njk` from `src/_includes/partials/` into reusable Astro components within a new `src/components/` directory.",
            "dependencies": [
              "7.1"
            ],
            "details": "Create `src/components/Header.astro`, `src/components/Footer.astro`, and `src/components/SkipLink.astro`. Migrate the HTML from the corresponding `.njk` files. Replace any Nunjucks syntax with static HTML or Astro variables. Import and place these new components into `src/layouts/Layout.astro`. The `SkipLink` should be placed at the beginning of the `<body>`, and the `Header` and `Footer` should wrap the `<main>` element.",
            "status": "done",
            "testStrategy": "Refresh the `test-layout.astro` page and verify that the header and footer now render correctly as part of the main layout."
          },
          {
            "id": 3,
            "title": "Migrate SEO Meta, JSON-LD, and AWS RUM Script",
            "description": "Migrate the advanced SEO meta tags, the `json-ld.njk` partial, and the AWS CloudWatch RUM script from `base.njk` into the `<head>` of `src/layouts/Layout.astro`.",
            "dependencies": [
              "7.1"
            ],
            "details": "Convert `src/_includes/partials/json-ld.njk` into a `src/components/JsonLD.astro` component that accepts props and uses `JSON.stringify()` within a `<script type=\"application/ld+json\">` tag. Copy the AWS RUM script block into `Layout.astro`, wrapping it in an Astro expression to ensure it only runs in production, e.g., `{import.meta.env.PROD && <script>...</script>}`. Add the remaining SEO meta tags (e.g., `og:title`, `twitter:card`) to `Layout.astro`, using the layout's props for dynamic content. Import and use the `JsonLD` component within the `<head>` of `Layout.astro`.",
            "status": "done",
            "testStrategy": "Inspect the source code of the `test-layout.astro` page. Verify that all meta tags are present, the JSON-LD script is correctly formatted, and the RUM script is included (when running a production preview)."
          },
          {
            "id": 4,
            "title": "Convert project-card.njk to a ProjectCard.astro Component",
            "description": "Convert the `src/_includes/partials/project-card.njk` partial into a reusable `src/components/ProjectCard.astro` component that accepts props for project data.",
            "dependencies": [],
            "details": "Create `src/components/ProjectCard.astro`. Analyze `project-card.njk` to identify the data it uses (e.g., `project.title`, `project.description`, `project.url`, `project.tags`). Define a `Props` interface in the component's frontmatter to type this data. Convert the Nunjucks template logic and variable placeholders (`{{ project.title }}`) to their Astro/JSX equivalents (`{project.title}`). Use `{project.tags.map(tag => <span>{tag}</span>)}` for loops.",
            "status": "done",
            "testStrategy": "Import the `ProjectCard.astro` component into `test-layout.astro`. Pass it a static mock project object as a prop. Verify the card renders correctly with the provided data."
          },
          {
            "id": 5,
            "title": "Create and Finalize a Test Page to Validate All Migrated Components",
            "description": "Create a comprehensive test page that utilizes the new `Layout.astro` and integrates all migrated components (`Header`, `Footer`, `JsonLD`, `ProjectCard`) to ensure they work together correctly.",
            "dependencies": [
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "Enhance the `src/pages/test-layout.astro` page. Ensure it uses `Layout.astro` and passes appropriate props for `title`, `description`, and data for the `JsonLD` component. Inside the page content, instantiate the `ProjectCard` component at least twice with different mock data to simulate a list. This page will serve as a complete integration test for all migrated layout and partial components.",
            "status": "done",
            "testStrategy": "Load the `test-layout.astro` page in the browser. Confirm the header, footer, and two project cards are all visible and styled correctly. Use browser dev tools to verify that the page title, meta description, JSON-LD data, and RUM script are all present and correct in the final HTML output."
          }
        ]
      },
      {
        "id": 8,
        "title": "Set Up Content Collections and Migrate Data Files",
        "description": "Establish Astro's Content Collections for the bilingual blog posts and migrate all global and i18n data files from the `src/_data` directory.",
        "details": "Create a `src/content/config.ts` file. Define a collection schema for blog posts that matches the frontmatter of the existing Markdown files. Move all blog post `.md` files into `src/content/blog/`. Migrate `site.json`, `certifications.json`, and `i18n.json` to a new `src/data/` directory. Create TypeScript types for this data to ensure type safety. Refactor any custom Eleventy filters (like `readableDate`) into JavaScript helper functions in a `src/utils/` directory.",
        "testStrategy": "Use `getCollection()` in a test page to query the blog posts and verify that the data is parsed correctly according to the schema. Import data from the new `src/data/` files and log it to the console on a test page to ensure it's accessible. Write unit tests for any new utility functions (e.g., date formatting).",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Blog Content Collection Schema",
            "description": "Create the `src/content/config.ts` file and define a Zod schema for the 'blog' collection that matches the frontmatter of the existing Markdown posts.",
            "dependencies": [],
            "details": "Based on the analysis of `src/posts/en/hello-world.md`, the schema in `src/content/config.ts` should include fields for `title` (string), `description` (string), `date` (date), `tags` (array of strings), `lang` (enum of 'en'/'es'), and `translationKey` (string). Use `z.object` from the `astro:content` import to define this structure.",
            "status": "done",
            "testStrategy": "After creation, run `npx astro check` to ensure the TypeScript configuration is valid and Astro recognizes the new collection schema."
          },
          {
            "id": 2,
            "title": "Migrate Blog Markdown Files to Content Collection",
            "description": "Move all bilingual blog post Markdown files from the `src/posts/` directory into the newly established `src/content/blog/` directory.",
            "dependencies": [
              "8.1"
            ],
            "details": "Create the `src/content/blog/` directory. Move all files from `src/posts/en/` and `src/posts/es/` into `src/content/blog/`. The existing language-specific subdirectories (`en/`, `es/`) should be flattened, as the `lang` property in the frontmatter will now be the source of truth for the post's language.",
            "status": "done",
            "testStrategy": "Run `npx astro check` again. If there are any mismatches between the frontmatter in the moved files and the schema defined in subtask 1, Astro's type checker will report errors."
          },
          {
            "id": 3,
            "title": "Migrate Data Files and Define TypeScript Types",
            "description": "Move `site.json`, `certifications.json`, and `i18n.json` from `src/_data/` to a new `src/data/` directory, and create TypeScript types for them.",
            "dependencies": [],
            "details": "Create a new directory `src/data/`. Move the three JSON files into it. Then, create a new file, `src/data/types.ts`, and define TypeScript interfaces or types (e.g., `SiteData`, `Certification`, `I18nData`) that match the structure of each JSON file to ensure type-safe imports across the project.",
            "status": "done",
            "testStrategy": "In a temporary test file, attempt to import the JSON data and cast it to the newly created types to ensure they match, e.g., `import siteData from '~/data/site.json'; const typedData: SiteData = siteData;`."
          },
          {
            "id": 4,
            "title": "Refactor 'readableDate' Eleventy Filter to a Utility Function",
            "description": "Re-implement the `readableDate` filter from `.eleventy.js` as a standalone TypeScript function in a new `src/utils/` directory.",
            "dependencies": [],
            "details": "Create a `src/utils/` directory if it doesn't exist. Create a file `src/utils/date.ts`. Inside this file, write a function `formatReadableDate(date: Date, lang: 'en' | 'es')` that takes a Date object and a language, and returns a formatted date string (e.g., 'Oct 26, 2023'). You can use the native `Intl.DateTimeFormat` API to replicate the logic from the original Luxon-based filter.",
            "status": "done",
            "testStrategy": "Create a unit test file for `date.ts` (e.g., `src/utils/date.test.ts`) using a framework like Vitest. Add test cases to verify that the function correctly formats dates for both English and Spanish locales."
          },
          {
            "id": 5,
            "title": "Create Test Page to Validate Data and Collection Migration",
            "description": "Create a temporary Astro page to query the new blog collection and import the migrated data files to verify that everything is accessible.",
            "dependencies": [
              "8.2",
              "8.3"
            ],
            "details": "Create a new page at `src/pages/test-migration.astro`. In the frontmatter script, use `getCollection('blog')` to fetch all blog entries. Also, import the data from `src/data/site.json` and `src/data/i18n.json`. In the template section, render the title of the first blog post and the site name from the imported data to confirm they are loaded correctly.",
            "status": "done",
            "testStrategy": "Run the dev server with `npm run dev` and navigate to `/test-migration`. Verify that the page renders without errors and that the blog post title and site name are displayed as expected in the browser."
          }
        ]
      },
      {
        "id": 9,
        "title": "Migrate Page Templates and Implement i18n Routing",
        "description": "Convert all main page templates (index, blog overview, etc.) from Nunjucks to Astro pages and implement Astro's i18n routing to handle the bilingual (EN/ES) structure.",
        "details": "Create Astro pages in `src/pages/` that correspond to the old Nunjucks templates (e.g., `src/pages/index.astro`, `src/pages/certifications.astro`). Utilize the i18n routing configuration from `astro.config.mjs` to generate pages for both `/en/` and `/es/`. Fetch data from Content Collections and data files to populate these pages. Create dynamic routes for blog posts, such as `src/pages/[lang]/blog/[slug].astro`, which will generate a page for each Markdown file in the blog collection.",
        "testStrategy": "Navigate to all pages in both English and Spanish (e.g., `/`, `/es/`, `/en/blog`, `/es/blog`). Verify that the correct content and language strings from `i18n.json` are displayed. Click on a blog post link and confirm that the dynamic route renders the correct Markdown content. Check that all internal links work correctly.",
        "priority": "high",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Migrate Homepage (index.njk) to an i18n Astro Page",
            "description": "Convert the Nunjucks homepage template into a single `src/pages/index.astro` file. This page will be automatically built by Astro for both English (`/`) and Spanish (`/es/`) routes based on the i18n configuration.",
            "dependencies": [],
            "details": "Create `src/pages/index.astro`. Use the `Layout.astro` component (from Task 7). Fetch UI strings like navigation labels and footer text from `src/data/i18n.json` using `Astro.currentLocale` to determine the language. Fetch project data from `src/data/projects.json` and render them using the `ProjectCard.astro` component. This will establish the primary pattern for migrating static pages with the configured i18n routing.\n<info added on 2025-09-17T22:39:24.352Z>\n**UPDATE:** The initial approach of using a single `src/pages/index.astro` resulted in a 404 error on the root path (`/`) because the `i18n` configuration `prefixDefaultLocale: true` requires all pages to be prefixed with a locale.\n\nTo resolve this, the implementation was adjusted:\n1.  The main homepage logic was moved to a dynamic route at `src/pages/[lang]/index.astro`.\n2.  A `getStaticPaths` function was added to this page to generate both the `/en/` and `/es/` versions.\n3.  A new, simple `src/pages/index.astro` was created to handle the root path. It contains only a redirect to the default locale's homepage (`/en/`). This ensures that users visiting the root domain are correctly forwarded.\n</info added on 2025-09-17T22:39:24.352Z>",
            "status": "done",
            "testStrategy": "Navigate to `/` and verify the English content is displayed. Navigate to `/es/` and verify the Spanish content is displayed. Check that project cards are rendered correctly on both versions."
          },
          {
            "id": 2,
            "title": "Migrate Static Page (certifications.njk) to an i18n Astro Page",
            "description": "Convert the Nunjucks certifications template into `src/pages/certifications.astro`. This page will leverage Astro's i18n routing to generate both `/certifications` and `/es/certifications`.",
            "dependencies": [
              "9.1"
            ],
            "details": "Create `src/pages/certifications.astro`. Follow the pattern established in the homepage migration. Use the main `Layout.astro` and fetch language-specific strings from `i18n.json` based on `Astro.currentLocale`. The content for certifications can be hardcoded within the Astro component for now, using conditional rendering or separate variables for EN/ES text.",
            "status": "done",
            "testStrategy": "Navigate to `/certifications` and verify English content. Navigate to `/es/certifications` and verify Spanish content. Ensure the correct header/footer translations are shown."
          },
          {
            "id": 3,
            "title": "Create an i18n-aware Blog Overview Page",
            "description": "Create a blog index page that lists posts appropriate for the selected language. This will replace `blog.njk` and use Astro's Content Collections.",
            "dependencies": [
              "9.1"
            ],
            "details": "Create the file `src/pages/blog/index.astro`. This page will be automatically built for `/blog` (en) and `/es/blog` (es). Inside the component script, use `getCollection('blog')` to fetch all blog entries. Filter the entries to show only those matching the current language by checking if `post.id` starts with `${Astro.currentLocale}/`. Map over the filtered posts and render links pointing to their respective detail pages (e.g., `/en/blog/some-post` or `/es/blog/algun-post`).\n<info added on 2025-09-17T22:33:52.941Z>\n**UPDATE:** The initial implementation plan was flawed and resulted in a 404 error for `/en/blog`. This was due to the `i18n: { prefixDefaultLocale: true }` setting in `astro.config.mjs`, which requires all routes to be prefixed with a language code. The following corrections were successfully implemented:\n\n- **File Path:** The page was moved from `src/pages/blog/index.astro` to `src/pages/[lang]/blog/index.astro`. This creates a dynamic route that correctly generates both `/en/blog` and `/es/blog`.\n- **Static Paths:** A `getStaticPaths` function was added to `src/pages/[lang]/blog/index.astro` to explicitly generate the page for each supported locale (`en` and `es`).\n- **Filtering Logic:** The logic for filtering posts was updated to match the project's file naming convention (`post-name.en.md`, `post-name.es.md`). Instead of checking if `post.id` starts with a locale, the filter now checks if the `post.slug` ends with `.${Astro.currentLocale}`.\n</info added on 2025-09-17T22:33:52.941Z>",
            "status": "done",
            "testStrategy": "Visit `/blog` and confirm only English posts are listed. Visit `/es/blog` and confirm only Spanish posts are listed. Click on a post title and verify it attempts to navigate to the correct dynamic URL."
          },
          {
            "id": 4,
            "title": "Create Dynamic i18n Route for Individual Blog Posts",
            "description": "Implement the dynamic route `[lang]/blog/[slug].astro` to generate a unique page for each Markdown file in the blog content collection, respecting both its language and slug.",
            "dependencies": [
              "9.3"
            ],
            "details": "Create the file `src/pages/[lang]/blog/[slug].astro`. Implement `getStaticPaths` to generate the routes. Fetch all posts using `getCollection('blog')`. For each post, extract the language and slug from its `id` (e.g., 'en/first-post'). Return an array of path objects, for example: `{ params: { lang: 'en', slug: 'first-post' }, props: { post } }`. The page component will then use `Astro.props.post` to access the post data and render its title, metadata, and body using the `<Content />` component.",
            "status": "done",
            "testStrategy": "After clicking a blog post link on the `/blog` or `/es/blog` pages, verify that the correct blog post content is rendered. Check that the URL matches the expected structure, like `/en/blog/first-post`."
          },
          {
            "id": 5,
            "title": "Implement Language Switcher and Unify Navigation Links",
            "description": "Update the header component to include a language switcher and ensure all navigation links are locale-aware, providing seamless navigation between English and Spanish sections of the site.",
            "dependencies": [
              "9.1",
              "9.2",
              "9.3",
              "9.4"
            ],
            "details": "Modify the `Header.astro` component. Add a UI element (e.g., a link or button) that allows users to switch between 'EN' and 'ES'. Use `Astro.url` to determine the current page's path and construct the URL for the alternate language. For static pages, this is straightforward (e.g., `/certifications` -> `/es/certifications`). For dynamic blog posts, you may need to add a `translationKey` to the frontmatter of related posts to find the correct corresponding slug. Update all navigation links in the header to use a helper function that generates the correct path, respecting the `prefixDefaultLocale: false` setting (e.g., links for 'en' should not have the `/en/` prefix).",
            "status": "done",
            "testStrategy": "On the homepage, click the language switcher and verify you are taken to the Spanish homepage. On a blog post page, click the switcher and verify you are taken to the translated version of that post (if it exists). Navigate the entire site in both languages to ensure no broken links."
          }
        ]
      },
      {
        "id": 10,
        "title": "Finalize Build, Verify SEO, and Test Deployment",
        "description": "Ensure the build process is fully functional, verify all SEO elements are preserved, conduct thorough end-to-end testing, and prepare for deployment.",
        "details": "Run `npm run build` to generate the static site. Inspect the output `dist/` directory to ensure all assets (CSS, JS, images) are processed and optimized correctly. Use browser developer tools and online checkers to verify that SEO meta tags, JSON-LD scripts, and the sitemap (`/sitemap-index.xml`) are correctly generated. Perform a full regression test of the site on multiple browsers and devices. Update any deployment scripts or CI/CD configurations to use the new Astro build commands.",
        "testStrategy": "Serve the build output locally using `npm run preview` and perform a final click-through of the entire site. Run a Lighthouse audit on key pages (homepage, blog post) to ensure performance and SEO scores are maintained or improved. Validate the generated sitemap using an online tool. Deploy to a staging environment and perform a final verification before pushing to production.",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Generate Production Build and Verify Asset Integrity",
            "description": "Run the Astro production build command and inspect the output directory to ensure all static assets are correctly processed, minified, and placed.",
            "dependencies": [],
            "details": "Execute `npm run build` in the terminal. After the build completes, navigate to the `dist/` directory. Verify that CSS and JS files are minified and have hash-based names for cache-busting. Check that images from `src/assets` are processed and that files from the `public/` directory are copied over correctly.",
            "status": "done",
            "testStrategy": "Confirm the `dist/` directory is created and populated. Check the file sizes of JS/CSS assets to ensure they are smaller than their source counterparts. Manually check for the existence of a few key images and public files (like `favicon.svg`) in the output."
          },
          {
            "id": 2,
            "title": "Validate SEO Meta Tags, JSON-LD, and Sitemap",
            "description": "Serve the production build locally and use browser tools and online validators to confirm that all SEO-related elements are correctly generated and preserved.",
            "dependencies": [
              "10.1"
            ],
            "details": "Run `npm run preview` to serve the `dist/` directory. Open the site in a browser and navigate to the homepage, a blog post page, and the projects page. Use the browser's developer tools (Elements and Network tabs) to inspect the `<head>` section. Verify that the `title`, `meta description`, `canonical` URL, Open Graph tags, and JSON-LD scripts generated by the `astro-seo` component are present and accurate. Locate the `dist/sitemap-index.xml` and its referenced sub-sitemaps, and validate them using an online sitemap validator.",
            "status": "done",
            "testStrategy": "On a blog post page, ensure the title and description are specific to that post. Check that the `og:image` tag is present. Use a tool like the Schema Markup Validator (schema.org) to test the JSON-LD output. Use a tool like XML-Sitemaps.com's validator for the sitemap."
          },
          {
            "id": 3,
            "title": "Conduct Cross-Browser and Responsive End-to-End Testing",
            "description": "Perform a full manual regression test on the locally served production build across different browsers and device sizes to catch any rendering or functionality issues.",
            "dependencies": [
              "10.1"
            ],
            "details": "With the site running via `npm run preview`, perform a thorough click-through of the entire website. Test all navigation links, interactive elements, and page layouts. Perform this testing on the latest versions of Chrome, Firefox, and Safari. Use the browser's responsive design mode to simulate and test on common mobile, tablet, and desktop viewport sizes.",
            "status": "done",
            "testStrategy": "Verify that the mobile navigation menu works as expected. Check that Tailwind CSS classes apply correctly across all tested browsers and viewports. Ensure there are no console errors on any page. Confirm that all internal links resolve correctly and there are no 404s."
          },
          {
            "id": 4,
            "title": "Run Lighthouse Audits for Performance and Accessibility",
            "description": "Use Google Lighthouse to audit key pages of the production build, ensuring high scores are maintained for performance, accessibility, best practices, and SEO.",
            "dependencies": [
              "10.1"
            ],
            "details": "While serving the site with `npm run preview`, open Chrome DevTools. Navigate to the 'Lighthouse' tab. Run a full audit (all categories) on the homepage and at least one content-heavy page, like a blog post. Analyze the report and identify any major regressions or areas for improvement.",
            "status": "done",
            "testStrategy": "Target scores of 90+ in all four Lighthouse categories. Pay close attention to the 'Performance' metrics like Largest Contentful Paint (LCP) and Cumulative Layout Shift (CLS). Address any critical accessibility issues reported by the audit."
          },
          {
            "id": 5,
            "title": "Update Deployment Platform Configuration",
            "description": "Configure the deployment service (e.g., Netlify, Vercel, GitHub Actions) to use the correct Astro build commands and settings for continuous deployment.",
            "dependencies": [
              "10.1",
              "10.2",
              "10.3",
              "10.4"
            ],
            "details": "Access your deployment platform's settings for this project. Update the 'Build Command' to `npm run build` or `astro build`. Set the 'Publish Directory' (or 'Output Directory') to `dist`. Ensure the Node.js version is set to a compatible version (e.g., 18.x or higher). If a `netlify.toml` or similar configuration file is preferred, create or update it with these settings.",
            "status": "done",
            "testStrategy": "Trigger a new deployment on the platform. After the build and deployment are complete, visit the live production URL and perform a quick smoke test to ensure the site is live and functioning as expected. Verify the domain and HTTPS are correctly configured."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-17T18:40:00.163Z",
      "updated": "2025-09-17T22:50:09.089Z",
      "description": "Tasks for astro-migration context"
    }
  },
  "beta-version": {
    "tasks": [
      {
        "id": 1,
        "title": "Tailwind CSS Configuration and Theme Setup",
        "description": "Configure Tailwind CSS with custom brand colors, typography scale, and responsive design system to support the design specifications",
        "details": "Extend tailwind.config.js to include custom color palette with brand-600 primary accent color, extended gray scale for better contrast, and custom color variables for dynamic tag colors. Configure typography scale with proper heading hierarchy (h1-h6), consistent font weights and line heights, and responsive font sizing. Set up spacing system with consistent padding/margin scales and responsive spacing utilities. Add custom prose styling for blog content with prose-lg configuration. Configure container max-widths and breakpoint system for responsive design.",
        "testStrategy": "Verify custom colors render correctly across all design elements, test typography hierarchy on different screen sizes, validate spacing consistency across components, and ensure prose styling works properly for markdown content rendering.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Custom Color Palette",
            "description": "Extend the Tailwind theme to include the project's custom color palette, including the primary brand color, an extended gray scale, and a set of colors for dynamic tags.",
            "dependencies": [],
            "details": "In `tailwind.config.js`, modify the `theme.extend.colors` object. Add a `brand` object with a `600` key for the primary accent color. Replace the default `colors.gray` with an extended palette (e.g., from 50 to 950) to provide more shades for UI elements and text, ensuring better contrast. Add a series of named colors (e.g., `tag-blue`, `tag-green`, `tag-yellow`) for use in blog post tags.",
            "status": "pending",
            "testStrategy": "Verify that `bg-brand-600`, `text-gray-950`, and `bg-tag-blue` classes can be applied to elements and render the correct colors in the browser."
          },
          {
            "id": 2,
            "title": "Set Up Responsive Typography Scale",
            "description": "Define a consistent and responsive typography scale for headings (h1-h6) and body text, including font sizes, weights, and line heights.",
            "dependencies": [],
            "details": "In `tailwind.config.js`, extend the `theme` with a `fontSize` object. Define sizes for `h1` through `h6` and standard text elements (`sm`, `base`, `lg`, `xl`). Use responsive array syntax for key elements to adjust font size across breakpoints, for example: `\"5xl\": [\"3rem\", { lineHeight: \"1.1\" }]`. Also, configure the `fontWeight` and `lineHeight` scales to ensure consistency.",
            "status": "pending",
            "testStrategy": "Create a test page with h1-h6 elements and paragraphs. Inspect the computed styles at different breakpoints to ensure font sizes, weights, and line heights match the configuration."
          },
          {
            "id": 3,
            "title": "Configure Layout System: Breakpoints, Spacing, and Containers",
            "description": "Establish the core responsive layout system by configuring custom breakpoints, the master spacing scale, and default container properties.",
            "dependencies": [],
            "details": "In `tailwind.config.js`, define the project's responsive breakpoints (e.g., sm, md, lg, xl, 2xl) in the `theme.screens` object. Review and extend the `theme.spacing` scale if necessary to match design specifications for padding and margins. Configure the `container` properties in the theme to set a `max-width` for each breakpoint and enable `center: true` to auto-margin the main layout container.",
            "status": "pending",
            "testStrategy": "Apply container classes and responsive spacing utilities (e.g., `p-4 md:p-8`) to a test component. Resize the browser window to verify that breakpoints trigger correctly and that container width and spacing adjust as expected."
          },
          {
            "id": 4,
            "title": "Install and Configure Tailwind Typography Plugin for Prose",
            "description": "Install the `@tailwindcss/typography` plugin and configure it to style markdown-rendered content for blog posts, customizing the `prose-lg` variant.",
            "dependencies": [],
            "details": "Run `npm install -D @tailwindcss/typography`. In `tailwind.config.js`, add `require('@tailwindcss/typography')` to the `plugins` array. Use the `theme.extend.typography` key to customize the default prose styles. Specifically, target the `lg` modifier to adjust styles for headings, links, paragraphs, and code blocks to align with the new brand colors and typography scale.",
            "status": "pending",
            "testStrategy": "Create a sample markdown file and render it on a page within a `div` that has the `prose prose-lg` classes. Verify that all elements (headings, links, lists, blockquotes) are styled correctly according to the theme customizations."
          },
          {
            "id": 5,
            "title": "Integrate Theme with Global Styles and CSS Variables",
            "description": "Update the main `globals.css` file to remove default styles, set base body styles using the new theme, and define CSS variables for dynamic tag colors.",
            "dependencies": [
              "1.1"
            ],
            "details": "In `src/styles/globals.css`, remove the boilerplate `:root` variables from the Next.js starter. Apply base styles to the `body` tag using `@apply` with utilities from the newly configured theme (e.g., `@apply bg-gray-50 text-gray-800;`). Define CSS variables in the `:root` selector for the dynamic tag colors to allow them to be easily applied programmatically in components.",
            "status": "pending",
            "testStrategy": "Load the application and inspect the `body` element to confirm the base background and text colors are applied. Verify that the custom CSS variables for tags are available globally in the browser's developer tools."
          }
        ],
        "tag": "beta-version",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "ui-styling",
              "toTag": "beta-version",
              "timestamp": "2025-09-18T01:26:38.001Z"
            }
          ]
        }
      },
      {
        "id": 2,
        "title": "Core Layout Components Enhancement",
        "description": "Enhance Header and Footer components with improved styling, navigation, and responsive behavior according to design specifications",
        "details": "Update Header component with clean typography using proper font weights, subtle border-bottom with border-gray-100, responsive padding (py-6 px-4 md:px-8), and maximum width container (max-w-7xl mx-auto). Style name as 'text-2xl font-bold text-gray-900' and implement CTA button with brand colors and skeumorphic shadow. Enhance language switcher with proper EN/ES toggle styling. Update Footer with simple horizontal layout, social icons as colored squares with letters/initials, centered copyright text with proper color contrast.",
        "testStrategy": "Test header responsiveness across breakpoints, verify CTA button hover states and accessibility, validate language switcher functionality, test footer social icon rendering and layout on mobile/desktop, and ensure proper contrast ratios for accessibility compliance.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Header Component Typography and Layout Enhancement",
            "description": "Update Header component with clean typography, proper font weights, and responsive layout structure",
            "dependencies": [],
            "details": "Implement clean typography with text-2xl font-bold text-gray-900 for name styling, apply proper font weights throughout the header, add responsive padding (py-6 px-4 md:px-8), and set up maximum width container (max-w-7xl mx-auto) with subtle border-bottom using border-gray-100",
            "status": "pending",
            "testStrategy": "Test typography rendering across different screen sizes, verify responsive padding adjustments, validate font weight consistency, and ensure border styling appears correctly"
          },
          {
            "id": 2,
            "title": "Header CTA Button Implementation",
            "description": "Implement call-to-action button with brand colors and skeumorphic shadow effects",
            "dependencies": [
              "2.1"
            ],
            "details": "Create CTA button using brand color palette with proper hover states, implement skeumorphic shadow effects for depth, ensure proper spacing and alignment within header layout, and add smooth transition animations",
            "status": "pending",
            "testStrategy": "Test button hover states and shadow effects, verify brand color implementation, validate button accessibility with focus indicators, and ensure smooth transitions"
          },
          {
            "id": 3,
            "title": "Language Switcher Enhancement",
            "description": "Enhance language switcher with proper EN/ES toggle styling and functionality",
            "dependencies": [
              "2.1"
            ],
            "details": "Style language switcher with proper toggle design for EN/ES options, implement active state styling, ensure proper spacing and alignment, and add smooth transition effects between language states",
            "status": "pending",
            "testStrategy": "Test language toggle functionality, verify active state styling, validate proper spacing within header layout, and ensure smooth state transitions"
          },
          {
            "id": 4,
            "title": "Footer Layout and Structure Implementation",
            "description": "Update Footer with simple horizontal layout and proper container structure",
            "dependencies": [],
            "details": "Implement simple horizontal layout for footer content, add proper container structure with consistent spacing, ensure responsive behavior across breakpoints, and set up foundation for social icons and copyright text",
            "status": "pending",
            "testStrategy": "Test footer layout responsiveness across breakpoints, verify horizontal alignment of elements, validate container structure and spacing consistency"
          },
          {
            "id": 5,
            "title": "Footer Social Icons and Copyright Styling",
            "description": "Implement social icons as colored squares with letters/initials and centered copyright text",
            "dependencies": [
              "2.4"
            ],
            "details": "Create social icons as colored squares containing letters or initials, implement proper color contrast for accessibility, add centered copyright text with appropriate typography, and ensure proper spacing between elements",
            "status": "pending",
            "testStrategy": "Test social icon rendering and color contrast ratios, verify copyright text centering and typography, validate accessibility compliance for color contrast, and ensure proper spacing on mobile and desktop"
          }
        ],
        "tag": "beta-version",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "ui-styling",
              "toTag": "beta-version",
              "timestamp": "2025-09-18T01:26:41.891Z"
            }
          ]
        }
      },
      {
        "id": 3,
        "title": "Homepage Sections Implementation",
        "description": "Implement all main page sections including Hero, Featured Work, Experience, and Certifications with enhanced visual styling and responsive layouts",
        "details": "Implement Hero section with two-column responsive grid (grid-cols-1 lg:grid-cols-2), left column with large bold typography (text-5xl md:text-6xl font-bold), branded italic text (text-brand-600 italic), description paragraph (text-xl text-gray-600 leading-relaxed), and right column with circular profile image (w-80 h-80 rounded-full) with proper object-cover scaling. Create Featured Work section with responsive grid (grid-cols-1 md:grid-cols-2 lg:grid-cols-3), white background cards with rounded corners (rounded-xl), subtle border and shadow effects, hover animations (hover:shadow-lg transition-all duration-300), and image overlay with dark gradient. Implement Experience section with enhanced cards featuring date/category badges, color-coded tags (bg-green-100 text-green-800), and improved hover states. Build Certifications section with responsive grid (grid-cols-2 md:grid-cols-3 lg:grid-cols-5), light gray background (bg-gray-50), centered certification badges (w-32 h-32), and clean typography for names and issuer information.",
        "testStrategy": "Test responsive layouts across all breakpoints, verify hover animations and transitions work smoothly, validate image loading and aspect ratios, test card hover states and focus management, ensure proper spacing and alignment across sections, and verify dynamic color generation for tags works correctly.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Prepare Homepage Layout and Create Section Component Files",
            "description": "Clean the boilerplate content from `src/app/page.tsx` and establish the main page layout. Create placeholder component files for Hero, FeaturedWork, Experience, and Certifications sections within the `src/components` directory to structure the implementation.",
            "dependencies": [],
            "details": "In `src/app/page.tsx`, remove the default Next.js content and set up a `<main>` element. Inside, import and render the new (currently empty) components in the correct order: `<Hero />`, `<FeaturedWork />`, `<Experience />`, `<Certifications />`. Create the following empty files: `src/components/Hero.tsx`, `src/components/FeaturedWork.tsx`, `src/components/Experience.tsx`, and `src/components/Certifications.tsx`. Each file should export a basic React functional component.",
            "status": "pending",
            "testStrategy": "Verify that `src/app/page.tsx` renders without errors and that the component files are created in the correct directory."
          },
          {
            "id": 2,
            "title": "Implement the Hero Section Component",
            "description": "Develop the Hero section in `src/components/Hero.tsx` with a two-column responsive layout, large typography, branded text, and a circular profile image as per the design specifications.",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement a `section` with a `max-w-7xl mx-auto` container and responsive padding. Use a responsive grid (`grid grid-cols-1 lg:grid-cols-2 gap-8 items-center`). The left column should contain an `h1` with `text-5xl md:text-6xl font-bold`, a `span` with `text-brand-600 italic`, and a `p` tag with `text-xl text-gray-600 leading-relaxed`. The right column should contain a Next.js `Image` component for the profile picture, styled with `w-80 h-80 rounded-full object-cover mx-auto lg:mx-0`.",
            "status": "pending",
            "testStrategy": "Test the Hero section's responsiveness, ensuring the layout switches from single to double column at the `lg` breakpoint. Verify typography scales correctly and the profile image maintains its aspect ratio and shape."
          },
          {
            "id": 3,
            "title": "Implement the Featured Work Section and Project Card",
            "description": "Build the Featured Work section, including a responsive grid and a reusable project card component with specified styling, hover animations, and an image overlay effect.",
            "dependencies": [
              "3.1"
            ],
            "details": "In `src/components/FeaturedWork.tsx`, create a section with a title and a responsive grid (`grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8`). Create a new `ProjectCard.tsx` component. This card should have a white background, `rounded-xl` corners, a subtle border, and shadow. Implement a `hover:shadow-lg transition-all duration-300` effect. The card's image should feature an overlay with a dark gradient that appears on hover.",
            "status": "pending",
            "testStrategy": "Verify the grid responsiveness across mobile, tablet, and desktop breakpoints. Test the card's hover animation for smoothness and ensure the image overlay appears correctly. Use placeholder images and text to validate the layout."
          },
          {
            "id": 4,
            "title": "Implement the Experience Section with Enhanced Cards",
            "description": "Create the Experience section, focusing on a list or timeline layout. Implement enhanced experience cards featuring date/category badges, color-coded skill tags, and improved hover states.",
            "dependencies": [
              "3.1"
            ],
            "details": "In `src/components/Experience.tsx`, create a section with a title. Design and implement an `ExperienceCard.tsx` component. This card should display a job title, company, and date range. Include a small badge for the category (e.g., 'Full-time'). Use flexbox to display a list of skill tags, styled with classes like `bg-green-100 text-green-800 rounded-full px-3 py-1 text-sm`. Implement a distinct hover state, such as a border color change or a subtle lift effect.",
            "status": "pending",
            "testStrategy": "Test the layout of experience cards. Verify that the color-coded tags render with the correct background and text colors. Check the hover state on the cards to ensure it provides clear visual feedback."
          },
          {
            "id": 5,
            "title": "Implement the Certifications Section",
            "description": "Build the Certifications section with a responsive grid layout on a light gray background to display certification badges and their corresponding names and issuers.",
            "dependencies": [
              "3.1"
            ],
            "details": "In `src/components/Certifications.tsx`, create a section with a `bg-gray-50` background and appropriate padding. Add a section title. Implement a responsive grid (`grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-8`). Each grid item should be a flex container (`flex flex-col items-center text-center`). It will contain a Next.js `Image` for the certification badge (`w-32 h-32 object-contain`), a `p` tag for the certification name (`font-semibold`), and another `p` tag for the issuer (`text-sm text-gray-500`).",
            "status": "pending",
            "testStrategy": "Verify the section's background color and padding. Test the grid's responsiveness to ensure the number of columns adjusts correctly at `md` and `lg` breakpoints. Check that images are centered and maintain their aspect ratio, and that the typography is clean and legible."
          }
        ],
        "tag": "beta-version",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "ui-styling",
              "toTag": "beta-version",
              "timestamp": "2025-09-18T01:26:43.863Z"
            }
          ]
        }
      },
      {
        "id": 4,
        "title": "Blog Pages Styling Implementation",
        "description": "Implement comprehensive styling for blog index page and individual blog post pages with enhanced cards, content rendering, and interactive elements",
        "details": "Style blog index page with clean page title typography, descriptive subtitle, featured posts in two-column grid with enhanced card design and hover effects, proper image handling and aspect ratios, and tag display with dynamic colors. Style regular posts section with list layout, thumbnail images, consistent spacing and typography, and smooth hover transitions. Implement individual blog post page with full-width background image hero section with dark overlay, post title/employer/date range display, dynamic tag colors in upper left corner, responsive typography and spacing. Create content area with description block, language toggle button ( English /  Spanish), main markdown content with prose prose-lg styling, proper code highlighting, Technologies Used section with dynamic tag/badge display, conditional Lucidchart embedding with proper iframe styling, and related posts grid with consistent card design.",
        "testStrategy": "Test blog index page layout and card hover effects, verify individual post page hero section responsiveness, validate markdown content rendering with proper typography, test language toggle functionality, ensure Lucidchart embeds display correctly when present, verify related posts grid layout, and test all interactive elements for accessibility.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Style Blog Index Page Header and Featured Posts Grid",
            "description": "Implement the styling for the main blog index page, including the page title, subtitle, and the two-column grid for featured posts. This involves enhancing the existing `BlogCard.astro` component with a new design, hover effects, and tag display.",
            "dependencies": [],
            "details": "In `src/pages/blog/index.astro`, style the `h1` and `p` tags for the page title and subtitle with clean, responsive typography. Modify the featured posts `div` to be a `grid grid-cols-1 md:grid-cols-2 gap-8`. Update `src/components/BlogCard.astro` to include a container with `rounded-lg`, `overflow-hidden`, and a subtle `shadow-md`. Implement a hover effect: `transition-all duration-300 hover:shadow-xl hover:-translate-y-1`. Ensure the post image uses `aspect-video` or a similar class for consistent aspect ratios with `object-cover`. Inside the card's content area, style the title, description, and implement a flex container to display tags using the `src/components/Tag.astro` component, applying dynamic colors based on the tag name.",
            "status": "pending",
            "testStrategy": "Verify the blog index page title and subtitle render correctly. Confirm the featured posts section displays as a two-column grid on medium screens and a single column on mobile. Test the hover effects on the blog cards for smooth transitions. Ensure images maintain their aspect ratio and tags are displayed with appropriate colors."
          },
          {
            "id": 2,
            "title": "Implement Regular Posts List Layout on Blog Index Page",
            "description": "Redesign the 'All Posts' section on the blog index page from a simple unordered list to a styled list layout, where each item includes a thumbnail, title, date, and description with hover transitions.",
            "dependencies": [],
            "details": "In `src/pages/blog/index.astro`, replace the `<ul>` for `regularPosts` with a `div` containing a loop. Each post item should be an `<a>` tag with `flex items-center gap-4` or `gap-6`. The link should have a subtle background color change on hover, e.g., `hover:bg-gray-50`. Inside the link, add a small, fixed-size image container (e.g., `w-32 h-20 flex-shrink-0`) for a thumbnail with `object-cover` and `rounded-md`. To the right of the image, create a `div` for the text content, including the post title with `font-bold`, the publication date in a smaller, lighter font, and a short description. Ensure consistent spacing and typography between list items.",
            "status": "pending",
            "testStrategy": "Check the regular posts section on `/blog` to ensure it's no longer a simple bulleted list. Verify each list item displays a thumbnail, title, and date. Test the hover effect on each list item. Ensure the layout is responsive and maintains alignment on different screen sizes."
          },
          {
            "id": 3,
            "title": "Create Individual Blog Post Hero Section",
            "description": "Implement the full-width hero section for individual blog post pages using the `BlogPostLayout.astro` file. This includes a background image with a dark overlay, and styled text for the title, employer, and date range.",
            "dependencies": [],
            "details": "In `src/layouts/BlogPostLayout.astro`, create a full-width `div` for the hero. Set the post's `image` from frontmatter as a background image. Add a semi-transparent dark overlay (e.g., `bg-black/50`) on top of the image to ensure text is readable. Inside a centered, max-width container, display the post tags in the upper-left corner using the `Tag.astro` component. Below the tags, display the post `title` with large, bold, white text (e.g., `text-4xl md:text-5xl font-bold text-white`). Under the title, display the `employer` and `dateRange` in a smaller, white font. Use flexbox or grid for layout and ensure the entire section is responsive.",
            "status": "pending",
            "testStrategy": "Navigate to an individual blog post page. Verify the hero section spans the full width and displays the correct background image. Check that the dark overlay is present and text is legible. Confirm that tags, title, employer, and date range are all correctly positioned and styled. Test responsiveness on mobile and desktop."
          },
          {
            "id": 4,
            "title": "Style Post Content Area, Markdown, and Language Toggle",
            "description": "Style the main content area of a blog post, including the description block, markdown content rendering with `prose`, code highlighting, and the 'Technologies Used' section.",
            "dependencies": [
              "4.3"
            ],
            "details": "In `src/layouts/BlogPostLayout.astro`, below the hero, create a main content container with a `max-w-4xl mx-auto` and appropriate padding. Add a distinct description block that stands out from the main content. Implement the language toggle button (/) if `post.data.language` is present. Wrap the `<slot />` (which renders the markdown) in a `div` with `prose prose-lg`. Ensure that `tailwind.config.mjs` is configured with `@tailwindcss/typography` and that styles for headings, links, lists, and code blocks are applied correctly. Below the markdown content, create a 'Technologies Used' section that iterates over the post's `tags` array and displays each one using the styled `Tag.astro` component.",
            "status": "pending",
            "testStrategy": "Verify the post description block is styled correctly. Check that markdown content is rendered with the specified `prose` styling for typography, spacing, and links. Confirm that code blocks have proper syntax highlighting. Test the language toggle button's appearance. Ensure the 'Technologies Used' section displays all tags correctly."
          },
          {
            "id": 5,
            "title": "Implement Conditional Lucidchart Embed and Related Posts Grid",
            "description": "Add the logic and styling for conditionally embedding a Lucidchart diagram and displaying a grid of related posts at the bottom of a blog post page.",
            "dependencies": [
              "4.1",
              "4.3"
            ],
            "details": "In `src/layouts/BlogPostLayout.astro`, add a conditional block that checks for `post.data.lucidchartId`. If it exists, render an `iframe` inside a responsive container that maintains a 16:9 aspect ratio. Style the iframe to have a `border` and `rounded-lg`. Below this, implement the 'Related Posts' section. Fetch the posts specified in the `post.data.relatedPosts` frontmatter array. Display these posts in a responsive grid (e.g., `grid-cols-1 md:grid-cols-2 gap-8`). Reuse the `src/components/BlogCard.astro` component (as styled in subtask 4.1) to display each related post, ensuring a consistent look and feel with the main blog index page.",
            "status": "pending",
            "testStrategy": "On a post with a `lucidchartId` in its frontmatter, verify the Lucidchart embed appears and is responsive. On a post without it, confirm the section is not rendered. On a post with `relatedPosts` defined, verify the related posts section appears and displays the correct posts using the `BlogCard` component. Check that the grid layout is responsive."
          }
        ],
        "tag": "beta-version",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "ui-styling",
              "toTag": "beta-version",
              "timestamp": "2025-09-18T01:26:46.084Z"
            }
          ]
        }
      },
      {
        "id": 5,
        "title": "Performance Optimization and Polish",
        "description": "Implement animations, optimize performance, ensure accessibility compliance, and conduct comprehensive testing across browsers and devices",
        "details": "Implement smooth hover effects with scale and shadow effects on cards, color transitions on links and buttons, proper image loading with lazy loading for below-fold content, and WebP format support where possible. Add loading states with proper placeholders and smooth content transitions. Ensure accessible focus indicators and keyboard navigation support. Optimize Tailwind CSS with unused class purging, minimize bundle size with critical CSS inlining, and implement proper caching headers. Add responsive images with srcset implementation. Conduct cross-browser testing (Chrome, Firefox, Safari, Edge) and mobile testing (iOS Safari, Chrome Mobile). Validate Core Web Vitals compliance with LCP optimization through hero image optimization and critical resource prioritization, CLS stability through proper image dimensions, and FID optimization with minimal JavaScript execution.",
        "testStrategy": "Run Lighthouse audits to achieve >90 score for all metrics, test page load times under 3G conditions, validate accessibility compliance with screen readers and keyboard navigation, conduct cross-browser compatibility testing, verify all animations work smoothly without performance issues, test responsive images loading correctly across devices, and ensure proper error handling for missing content or failed image loads.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Advanced Image Optimization with Astro Image",
            "description": "Replace all standard `<img>` tags with Astro's built-in `<Image>` component to automatically generate responsive `srcset` attributes, serve next-gen WebP formats, and handle lazy-loading for below-the-fold images. This will also prevent Cumulative Layout Shift (CLS) by enforcing image dimensions.",
            "dependencies": [],
            "details": "First, install an image integration if one is not present (e.g., `npx astro add image`). Then, go through all components and pages (e.g., `src/components/Card.astro`, `src/pages/blog/[...slug].astro`) and refactor existing `<img>` tags to use the `<Image>` component. Ensure the hero image on the homepage and blog posts is prioritized (not lazy-loaded) to optimize Largest Contentful Paint (LCP). For all other images, use the default lazy-loading behavior.",
            "status": "pending",
            "testStrategy": "Verify that images are served in WebP format in supported browsers. Inspect the generated HTML to confirm `srcset` and `sizes` attributes are present. Use browser dev tools to confirm that below-the-fold images are lazy-loaded on scroll. Run a Lighthouse audit to check for improvements in LCP and CLS scores."
          },
          {
            "id": 2,
            "title": "Enhance UI with Smooth Animations and Transitions",
            "description": "Implement smooth hover and transition effects on interactive elements to improve user experience. This includes adding scale and shadow effects to cards and ensuring smooth color transitions on links and buttons.",
            "dependencies": [],
            "details": "In component files like `src/components/Card.astro` and `src/components/Button.astro`, add Tailwind CSS utility classes. For cards, use a combination of `transition`, `duration-300`, `ease-in-out`, `hover:scale-105`, and `hover:shadow-xl`. For links and buttons, ensure the `transition-colors` class is applied to provide smooth feedback on hover and focus states.",
            "status": "pending",
            "testStrategy": "Manually test all cards, buttons, and links across the site to ensure hover animations are smooth and not janky. Verify that transitions work as expected in Chrome, Firefox, and Safari. Check for any performance degradation using the browser's performance profiler during animations."
          },
          {
            "id": 3,
            "title": "Improve Accessibility with Focus Indicators and Keyboard Navigation",
            "description": "Ensure the entire website is fully accessible via keyboard and that all interactive elements have clear, visible focus states to comply with WCAG standards.",
            "dependencies": [],
            "details": "In the global stylesheet (`src/styles/global.css`), add site-wide styles for the `:focus-visible` pseudo-class to provide a distinct outline or box-shadow on focused elements, overriding the default browser outline. A good pattern is `*:focus-visible { outline: 2px solid theme('colors.brand.600'); outline-offset: 2px; }`. Then, perform a full keyboard audit by tabbing through all pages to ensure the focus order is logical and all interactive elements (links, buttons, form fields) are reachable and operable.",
            "status": "pending",
            "testStrategy": "Navigate the entire website using only the Tab key. Confirm that every interactive element receives focus and has a visible indicator. Ensure the focus order follows the visual layout. Use a screen reader (e.g., VoiceOver, NVDA) to verify a seamless navigation experience."
          },
          {
            "id": 4,
            "title": "Optimize Build Output and Implement Caching Strategy",
            "description": "Ensure the production build is optimized by verifying Tailwind CSS purging is working correctly and implementing a proper browser caching strategy via server headers.",
            "dependencies": [],
            "details": "Verify that the `content` array in `tailwind.config.cjs` correctly includes all files containing Tailwind classes. For caching, create a configuration file for the deployment platform (e.g., a `public/_headers` file for Netlify/Cloudflare Pages or a `vercel.json` for Vercel). In this file, set aggressive `Cache-Control` headers for immutable assets in the `/_astro/` directory (e.g., `Cache-Control: public, max-age=31536000, immutable`). For HTML pages, use a revalidation strategy (e.g., `Cache-Control: public, max-age=0, must-revalidate`).",
            "status": "pending",
            "testStrategy": "After deployment, inspect the production site's CSS file to confirm its size is minimal and unused classes have been purged. Use browser dev tools' Network tab to inspect the response headers for assets and HTML documents, verifying that the `Cache-Control` headers are set as configured."
          },
          {
            "id": 5,
            "title": "Final Polish: Loading States, Resource Prioritization, and CWV Validation",
            "description": "Implement final performance optimizations by preloading critical resources and adding loading states. Conduct a comprehensive Core Web Vitals audit to ensure all metrics meet the 'good' threshold.",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "In `src/layouts/Layout.astro`, add `<link rel=\"preload\">` tags in the `<head>` for the LCP image (e.g., the hero image) and any critical fonts to prioritize their loading. If any components fetch data on the client-side, implement skeleton placeholder UIs. Finally, run a full Lighthouse audit on key pages (homepage, blog index, blog post) and analyze the results. Address any remaining issues to achieve a score of >90 across Performance, Accessibility, Best Practices, and SEO.",
            "status": "pending",
            "testStrategy": "Run Lighthouse in an incognito window to get accurate performance metrics. Test the site on a simulated 3G network using browser dev tools to assess perceived performance and loading behavior. Validate that LCP is under 2.5s, CLS is under 0.1, and FID (or INP) is low. Confirm the final Lighthouse scores are above 90."
          }
        ],
        "tag": "beta-version",
        "metadata": {
          "moveHistory": [
            {
              "fromTag": "ui-styling",
              "toTag": "beta-version",
              "timestamp": "2025-09-18T01:26:48.064Z"
            }
          ]
        }
      }
    ],
    "metadata": {
      "created": "2025-09-18T01:05:10.171Z",
      "updated": "2025-09-18T01:05:10.171Z",
      "description": "Tag created from git branch \"beta-version\""
    }
  }
}